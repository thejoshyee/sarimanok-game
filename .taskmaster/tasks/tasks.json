{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Core Player Movement",
        "description": "Set up the Godot 4.x project with correct viewport and input mappings. Implement the Sarimanok player character with 8-directional movement, sprite flipping, and 2-frame animation using placeholder sprites.",
        "details": "Configure project settings for 640x360 viewport with canvas_items stretch mode. Map input actions for movement (WASD/Arrow keys) and pause. Create CharacterBody2D player node with collision shape. Implement movement using Input.get_action_strength() for analog support. Add sprite child node with placeholder ColorRect. Implement horizontal sprite flipping based on velocity.x. Animate between 2 frames every 0.2 seconds while moving. Include invincibility frames after damage (0.5s).",
        "testStrategy": "Verify player moves smoothly in all 8 directions with correct speed per variant stats. Confirm sprite flips horizontally when moving left/right. Check 2-frame animation cycles while moving and stops when idle. Test invincibility frames prevent damage for 0.5s after hit. Ensure no console errors.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Project Viewport and Window Settings",
            "description": "Set up the Godot 4.x project viewport to 640x360 resolution with canvas_items stretch mode enabled.",
            "dependencies": [],
            "details": "Open Project Settings, navigate to Display -> Window, set Viewport Width to 640 and Viewport Height to 360. Enable canvas_items stretch mode to ensure proper scaling. Verify settings apply correctly on project start.",
            "status": "pending",
            "testStrategy": "Launch the project and confirm the viewport size is 640x360 and the window scales correctly without distortion."
          },
          {
            "id": 2,
            "title": "Map Input Actions for Movement and Pause",
            "description": "Define input mappings for player movement using WASD and arrow keys, plus a pause action.",
            "dependencies": [
              1
            ],
            "details": "In Project Settings under Input Map, add actions for 'move_up', 'move_down', 'move_left', 'move_right' mapped to W, S, A, D and arrow keys respectively. Add a 'pause' action mapped to the Escape key. Ensure analog input support by using Input.get_action_strength() in code.",
            "status": "pending",
            "testStrategy": "Test input actions in the editor by printing action strengths and verifying pause toggles correctly."
          },
          {
            "id": 3,
            "title": "Create Player Character Node with Collision",
            "description": "Create a CharacterBody2D node named Sarimanok with a collision shape for player physics.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add a CharacterBody2D node as the player root. Attach a CollisionShape2D child with an appropriate shape (e.g., RectangleShape2D) matching the player size. This node will handle movement and collision detection.",
            "status": "pending",
            "testStrategy": "Run the scene and verify the player collides properly with environment boundaries and does not pass through obstacles."
          },
          {
            "id": 4,
            "title": "Implement 8-Directional Movement and Horizontal Sprite Flipping",
            "description": "Program player movement in 8 directions using Input.get_action_strength(), and flip the sprite horizontally based on movement direction.",
            "dependencies": [
              3
            ],
            "details": "Use Input.get_action_strength() for each direction to calculate velocity vector. Normalize and apply movement speed. Add a Sprite2D child node with a placeholder ColorRect texture. Flip the sprite horizontally when velocity.x is negative, unflip when positive.",
            "status": "pending",
            "testStrategy": "Verify player moves smoothly in all 8 directions and sprite flips correctly when moving left or right."
          },
          {
            "id": 5,
            "title": "Add 2-Frame Animation and Invincibility Frames",
            "description": "Animate the player sprite cycling between 2 frames every 0.2 seconds while moving, and implement 0.5 second invincibility frames after damage.",
            "dependencies": [
              4
            ],
            "details": "Create an animation timer to switch between two placeholder frames on the sprite while the player is moving. When the player takes damage, trigger invincibility state lasting 0.5 seconds during which damage is ignored and optionally show visual feedback.",
            "status": "pending",
            "testStrategy": "Confirm the sprite animates only when moving, stops when idle, and that the player cannot take damage during invincibility frames after being hit."
          }
        ]
      },
      {
        "id": 2,
        "title": "Enemy System Implementation",
        "description": "Implement all 4 enemy types (Green Duwende, Red Duwende, Santelmo, Manananggal boss) with behaviors, spawning at screen edges, damage on contact, and death drops of XP and Gold.",
        "details": "Create enemy scenes using Area2D for performance. Implement movement toward player with simple vector math. Green and Red Duwendes walk toward player; Santelmo floats with sine wave and shoots fireballs every 2 seconds; Manananggal flies and performs dive attacks with telegraph. Implement spawn manager tracking elapsed time to spawn enemies per timeline and spawn rate scaling. Use object pooling for enemies and projectiles. On death, play particle effect, drop XP gem and Gold coin, and return enemy to pool.",
        "testStrategy": "Spawn enemies at correct times and rates. Confirm enemies move toward player and damage on contact. Verify Santelmo shoots fireballs with correct specs. Check Manananggal boss spawns at 20:00 with dive attacks and blood trail. Confirm enemies drop correct XP and Gold amounts. Test performance with 100+ enemies on screen. No console errors.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Weapon System with Data-Driven Architecture",
        "description": "Implement 6 weapons (Peck, Wing Slap, Feather Shot, Spiral Feathers, Ice Shard, Flame Wing) with auto-fire, cooldowns, upgrades, and debuff system using WeaponData Resource for data-driven definitions.",
        "details": "Create base Weapon class with cooldown timer and firing logic. Extend for melee, AOE, projectile, and orbital types. Implement debuff system for slow effect (used by Ice Shard). Use WeaponData Resource files to define weapon stats, visuals, and upgrade paths. Enforce max 4 weapons equipped. Clone weapons reuse base logic with different data. Show damage numbers on enemy hit and enemy flash on damage. Visual effects for weapon attacks.",
        "testStrategy": "Verify each weapon auto-fires on cooldown with correct behavior. Confirm upgrades increase damage and effects per level. Test debuff slow applies correctly for Ice Shard. Check damage numbers appear on enemy hits. Ensure max weapon limit enforced. No console errors.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Passive System Implementation",
        "description": "Implement 4 passives (Iron Beak, Thick Plumage, Racing Legs, Magnetic Aura) that stack additively and affect player stats. Integrate passives into level-up choices and player stat calculations.",
        "details": "Create Passive manager tracking levels per passive. Apply stat modifiers to player damage, max HP, move speed, and pickup range. Passives appear in level-up pool and can be upgraded to level 5. Update player stats dynamically based on passives and shop upgrades. No visual effects needed, only stat changes.",
        "testStrategy": "Confirm each passive increases correct stat per level. Verify passives stack additively with shop bonuses. Check passives appear in level-up choices and upgrade correctly. No console errors.",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Level-Up System with Upgrade Choices",
        "description": "Implement XP collection, XP bar UI, level-up triggers, and level-up screen presenting 3 random upgrade choices (weapons or passives). Pause game during level-up and apply chosen upgrade.",
        "details": "Collect XP from pickups to fill XP bar. When XP threshold reached, pause game and show level-up UI with 3 random valid choices respecting max levels and weapon slot limits. On choice selection, apply upgrade (add new weapon or upgrade existing weapon/passive) and resume game. Update XP thresholds per level using formula.",
        "testStrategy": "Verify XP bar fills on XP pickup. Confirm level-up triggers at correct XP amounts. Check game pauses and resumes correctly. Validate 3 random choices respect max levels and weapon slots. Confirm upgrades apply correctly. No console errors.",
        "priority": "high",
        "dependencies": [
          1,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Pickup System for XP and Gold",
        "description": "Implement XP gem and Gold coin pickups that spawn on enemy death, drift magnetically toward player when close, and add to XP bar or permanent gold counter on collection.",
        "details": "Create pickup scenes with Area2D and sprites. Spawn pickups at enemy death location. After 0.5s pause, pickups drift toward player within pickup range using magnet effect. On overlap with player, add XP or gold accordingly, play collect sound, and show floating '+1' text. Pickup range affected by Magnetic Aura passive.",
        "testStrategy": "Confirm pickups spawn correctly on enemy death. Verify pickups pause then drift toward player when in range. Check XP and gold counters update on collection. Play collection sounds and floating text appear. No console errors.",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Shop System for Permanent Upgrades",
        "description": "Implement shop UI accessible from main menu to spend gold on permanent upgrades (Damage, Max HP, Move Speed). Upgrades apply to all future runs and persist in save file.",
        "details": "Create shop screen UI showing current gold and upgrade options with costs. Disable buy button if insufficient gold. Deduct gold on purchase and update shop upgrade counters. Apply shop bonuses to player stats at run start. Save and load shop data from user://save_data.json with backup. Reflect current bonuses in UI.",
        "testStrategy": "Verify shop displays correct gold and upgrade info. Confirm buying upgrades deducts gold and applies bonuses. Check upgrades persist after game restart. Disable buy button when broke. No console errors.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Game Timer, Win and Lose Conditions",
        "description": "Implement 30-minute timer counting up, victory condition at 30:00 with dawn effect and crow sound, defeat condition at 0 HP with death animation, and results screen showing stats and options.",
        "details": "Display timer at top center in MM:SS format. When timer reaches 30:00, freeze gameplay, play dawn visual effect, show 'COCKADOODLEDOO!' text and sound, then results screen with stats (time, kills, score, gold). On player HP 0, play death animation and defeat results screen. Results screen allows retry, shop, or menu.",
        "testStrategy": "Confirm timer counts up correctly. Verify victory triggers at 30:00 with effects and sound. Check defeat triggers at 0 HP with animation. Results screen shows correct stats and buttons work. No console errors.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Character Select Screen and Unlock System",
        "description": "Implement character select screen before run with 3 Sarimanok variants (Classic, Shadow, Golden), showing unlock requirements and unlocking Shadow at 15:00 survived and Golden after beating Story Mode.",
        "details": "Create character select UI showing all 3 variants with stats and color differences. Lock Shadow until player survives 15:00 in Story Mode, lock Golden until Story Mode beaten (30:00). Update unlock flags in GameState. Allow selection of unlocked characters only. Reflect character stats in gameplay.",
        "testStrategy": "Verify character select screen displays all variants with correct info. Confirm locked characters show requirements. Test unlocking Shadow after 15:00 survival and Golden after Story Mode win. Selected character stats apply in run. No console errors.",
        "priority": "medium",
        "dependencies": [
          1,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Endless Mode Implementation and Unlock",
        "description": "Implement simplified Endless Mode unlocked after beating Story Mode. Endless Mode has no 30:00 win condition, same scaling as Story Mode, and tracks best time.",
        "details": "Add Endless Mode button locked initially on main menu. Unlock after Story Mode victory. In Endless Mode, timer counts up indefinitely, no victory condition. Use same spawn rate and enemy stat scaling as Story Mode continuing past 30:00. Save best time survived. Display best time on menu.",
        "testStrategy": "Confirm Endless Mode locked initially. Verify unlock after Story Mode win. Check timer counts up with no win condition. Confirm scaling continues past 30:00. Best time updates and displays correctly. No console errors.",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-04T05:56:20.743Z",
      "updated": "2025-12-04T05:56:20.743Z",
      "description": "Tasks for master context"
    }
  }
}