{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Audit existing Godot project setup",
        "description": "Inspect the current Godot 4 project to understand scenes, scripts, and configuration already in place.",
        "details": "Review the Godot project structure, main scene, autoloads (singletons), and any existing player, enemy, weapon, or progression scripts to avoid duplicating work.[1] Document what systems already exist (e.g., movement, input actions, basic UI, pooling helpers) and how they are organized (folders, naming conventions, node hierarchies).",
        "testStrategy": "Open the project in Godot, load the main scene, and verify that it runs without errors. Confirm that all referenced scripts and resources exist and that there are no missing dependencies reported in the editor.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Catalog scene and node hierarchy",
            "description": "Inspect and document the main scenes and their node structures in the existing Godot 4 project.",
            "dependencies": [],
            "details": "Concrete inspection steps:\n- Open the project and identify the main entry scene from Project Settings → Run or any bootstrapping script.\n- For the main scene and any key gameplay scenes (e.g., level, player, enemy, UI), expand the node tree and record top-level nodes and important child nodes (player, enemies, spawners, UI roots, cameras, tilemaps, game manager, etc.).\n- Note custom node types, groups, and signals used for communication between nodes.\n- Capture how scenes are composed (instanced scenes, inherited scenes, prefabs for enemies/weapons/projectiles, etc.).\n\nExpected artifacts:\n- Hierarchy notes (e.g., a text outline of each important scene’s node tree).\n- One or more simple diagrams (e.g., boxes and arrows) showing relationships between main gameplay scenes and key nodes.\n- A short summary listing which scenes are responsible for core flows (boot, gameplay, menus).\n\nCompletion criteria:\n- Main and core gameplay scenes are identified and their high-level node hierarchies are documented.\n- All major gameplay-relevant nodes (player, enemies, projectiles, spawners, UI root, camera, game manager) are listed with their roles.\n- Any use of scene inheritance or composition patterns is noted clearly enough to onboard a new developer.\n<info added on 2025-12-05T13:26:40.268Z>\nMain scene `game/main.tscn` is a minimal placeholder with a `Node2D` root and a `ColorRect` sized to 640×360, and there are no additional nodes, scripts, or logic present. All organizational folders for future gameplay content exist (`scenes/player`, `scenes/enemies`, `scenes/ui`, `scenes/weapons`, `scenes/levels`, `scripts`, `autoloads`) but are currently empty, confirming that there are no autoloads or global singletons defined yet and that the project is effectively a clean slate ready for new systems.\n</info added on 2025-12-05T13:26:40.268Z>",
            "status": "done",
            "testStrategy": null,
            "updatedAt": "2025-12-05T13:26:47.206Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Inventory autoloads and global singletons",
            "description": "Review and document all autoloads (singletons) and other global access patterns in the project.",
            "dependencies": [
              1
            ],
            "details": "Concrete inspection steps:\n- Open Project Settings → Autoload and list all configured autoload scripts/scenes, including their node names and paths.\n- Open each autoload script to identify its responsibilities (e.g., game state, config, audio manager, save system, object pools, progression data).\n- Search the codebase for get_singleton-like access patterns (e.g., references via global variables, static classes, or hardcoded node paths from root) and note any de facto globals.\n\nExpected artifacts:\n- A table or checklist of all autoloads with fields: name, path, type (script/scene), main responsibilities, and where they are used.\n- Notes on any additional global-style access (e.g., using /root paths, static helpers) that function like singletons.\n\nCompletion criteria:\n- Every entry in the Autoload settings is accounted for and described at a high level.\n- All major global systems are mapped and their intended usage is understandable.\n- Potential overlaps or redundant global responsibilities (e.g., multiple game-state managers) are identified, even if not yet resolved.\n<info added on 2025-12-05T13:28:29.596Z>\nAutoload/Singleton audit: Project Settings → Autoload tab is currently empty, and the `autoloads/` folder contains no scripts or scenes, so there are no configured global singletons or de facto global systems yet. This matches the empty/global-less state observed in the earlier scene and folder catalog, and implies that upcoming work will need to introduce new autoloads for core systems such as the PRD-defined `GameState` singleton, a save/load manager, an object pooling manager, and any other cross-scene utilities required for gameplay and progression.\n</info added on 2025-12-05T13:28:29.596Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:28:57.447Z"
          },
          {
            "id": 3,
            "title": "Review existing gameplay systems",
            "description": "Analyze and document current implementations of movement, combat, progression, and UI systems.",
            "dependencies": [
              1,
              2
            ],
            "details": "Concrete inspection steps:\n- Locate and open scripts for the player, enemies, and any weapons or projectiles to understand movement, input handling, and combat logic (damage, health, attacks, cooldowns, etc.).\n- Identify any existing progression-related scripts (XP, level, stats, upgrades) and note their data structures and integration points with gameplay.\n- Review UI scenes and scripts for HUD, pause menu, inventory/upgrade screens, and any existing bindings to gameplay data (signals, direct node references, autoloads).\n- Note use of groups, signals, and helper utilities (e.g., pooling, timers, spawn managers) that support gameplay.\n\nExpected artifacts:\n- Short system summaries for: movement, combat, progression, and UI, each listing key scripts, scenes, and how they interact.\n- A checklist indicating which systems already exist, which are partially implemented, and which appear missing or placeholder.\n- Optional sequence notes describing main gameplay flow (e.g., player input → movement → enemy spawn → damage → XP gain → UI update).\n\nCompletion criteria:\n- For each domain (movement, combat, progression, UI), there is a clear written description of what is implemented, where it lives, and how stable/complete it appears.\n- Existing systems that can be reused or extended (instead of rewritten) are explicitly identified.\n- Gaps or inconsistencies relevant to future tasks (e.g., planned progression loop, performance test scene) are noted.\n<info added on 2025-12-05T13:29:18.124Z>\nGameplay systems audit confirms that there are currently no implemented gameplay-related scripts or scenes in the project (movement, combat, progression, UI, or helper utilities), and all of these domains will need to be created from scratch in the existing empty-but-organized folder structure.\n</info added on 2025-12-05T13:29:18.124Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:29:24.841Z"
          },
          {
            "id": 4,
            "title": "Document coding conventions and organization",
            "description": "Identify and record the project’s coding style, folder layout, and naming conventions.",
            "dependencies": [
              1
            ],
            "details": "Concrete inspection steps:\n- Review the top-level folder structure (e.g., scenes, assets, scripts, addons, autoloads) and note how files are grouped by feature, type, or layer.\n- Sample a representative set of scripts to observe style: naming of classes, methods, signals, exported variables, use of type hints, and file naming patterns (snake_case, PascalCase, etc.).\n- Check node naming patterns in scenes (e.g., PascalCase or camelCase, suffixes like _Root, _UI, _Manager) and how they align with Godot 4 best practices.\n- Note any use of script organization helpers (e.g., script templates, common base classes, utils folders).\n\nExpected artifacts:\n- A concise style and organization note (1–2 pages) describing folder layout, naming conventions, and typical script patterns.\n- A brief checklist mapping current practices against Godot 4 organization recommendations (e.g., consistent file casing, keeping related assets near scenes).\n\nCompletion criteria:\n- Folder and naming conventions are documented well enough for new work to align without guesswork.\n- Any major deviations from common Godot 4 organization best practices are called out for later cleanup decisions.\n- There is a written recommendation on whether to adopt the existing style as-is or plan gradual refactors.\n<info added on 2025-12-05T13:30:24.329Z>\nSince the project is currently empty, document that this subtask will establish baseline Godot 4 conventions rather than auditing existing patterns. Add the following to the subtask details:\n\n\"Since the current Godot project is effectively empty, this subtask will define and document the initial coding conventions and organization rather than surveying existing implementations. Adopt the following Godot 4–aligned standards for all new work:\n\n- Folder layout:\n  - `scenes/` organized by feature or entity (player, enemies, ui, weapons, levels).\n  - `scripts/` for standalone or shared scripts not tightly bound to a single scene.\n  - `autoloads/` for singleton systems configured in Project Settings → Autoload.\n  - `assets/` organized by type (sprites, audio, fonts, etc.), with a strong preference to keep assets close to their consuming scenes where practical.\n  - `resources/` for custom `Resource` types and data-driven configs.\n\n- Naming conventions:\n  - Files: snake_case (e.g., `player_controller.gd`, `main_menu.tscn`).\n  - Scene files: named to match their main node’s role or type (e.g., `player.tscn` for the Player scene).\n  - Classes: PascalCase using `class_name` where reusable (e.g., `class_name PlayerController`).\n  - Variables and functions: snake_case (e.g., `move_speed`, `_on_hit`).\n  - Constants: UPPER_SNAKE_CASE (e.g., `MAX_ENEMIES`).\n  - Signals: snake_case (e.g., `health_changed`, `enemy_died`).\n  - Private/helper functions: prefixed with an underscore (e.g., `_update_velocity`).\n\n- Node and scene patterns:\n  - Node names in scenes use PascalCase and are descriptive (e.g., `Player`, `HealthBar`, `SpawnTimer` rather than generic `Node2D`).\n  - Prefer one main script per scene; factor complex behaviors into helper or component scripts under `scripts/` or feature-specific subfolders.\n  - Use `@onready` for node references, and use exported variables for inspector configuration.\n  - Apply type hints consistently (e.g., `var speed: float = 200.0`) and define signals for communication instead of tightly coupled node references.\n  - Use custom `Resource` types for data such as enemy stats, weapon configs, and other tunable parameters.\n\n- Style and design guidelines:\n  - Use 4-space indentation (Godot default).\n  - Keep functions small and focused (target range ~5–15 lines where reasonable).\n  - Write brief comments that explain intent/“why” rather than restating obvious behavior.\n  - Prefer composition over inheritance for extensibility and maintainability.\n\nRecommendation: Treat these conventions as the project’s baseline standard going forward. New scenes, scripts, and systems for other tasks (e.g., player controller, input setup, pooling infrastructure) should be implemented under this structure so that future contributors can align with the documented patterns without guesswork. Any future deviations should be deliberate and documented for later cleanup or refactor planning.\"\n</info added on 2025-12-05T13:30:24.329Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:30:31.102Z"
          },
          {
            "id": 5,
            "title": "Validate project health and integrity",
            "description": "Assess the project for missing resources, errors, warnings, and general editor health, and document findings.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Concrete inspection steps:\n- Open the project, run the main scene, and observe the Output and Debugger panels for errors or warnings at startup and during basic interaction.\n- Use the Godot 4 debugger and Profiler panels to look for recurring script or node issues (e.g., invalid call targets, failed resource loads).\n- Scan the FileSystem dock for broken resource icons and open key scenes to check for missing or broken references (e.g., empty script slots, missing textures, invalid audio paths).\n- Optionally run the built-in project validator (if available) or use a simple manual checklist to confirm there are no obvious import or path issues.\n\nExpected artifacts:\n- A health report listing current errors, warnings, and broken references, each with scene/script location and a short description.\n- A prioritized checklist of recommended fixes (critical, important, cosmetic) to stabilize the foundation for upcoming tasks.\n\nCompletion criteria:\n- Main scene runs without uninvestigated errors or critical warnings, or any remaining issues are clearly documented with rationale for deferring fixes.\n- No known missing scripts or resources in core gameplay and UI scenes, or all such issues are logged.\n- There is a clear go/no-go statement for proceeding with dependent tasks (resolution setup, input configuration, progression and performance work) based on project health.\n<info added on 2025-12-05T13:31:32.502Z>\nProject health validation complete. Main scene runs cleanly in Godot 4.5.1 with no errors, warnings, missing resources, or broken references during startup or basic interaction, and the editor shows no broken resource icons, missing scripts, or import issues. Status: GO for all dependent tasks (resolution setup, input configuration, gameplay systems, and later performance validation), with the project considered a clean, well-organized starting point and no technical debt or stabilization work required before proceeding.\n</info added on 2025-12-05T13:31:32.502Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:31:38.640Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break this task into subtasks that (1) catalog the current scene and node hierarchy, (2) inventory autoloads and global singletons, (3) review existing gameplay systems (movement, combat, progression, UI), (4) document coding conventions and folder/naming patterns, and (5) validate project health (missing resources, errors, warnings). For each subtask, specify concrete inspection steps, expected artifacts (notes, diagrams, checklists), and clear completion criteria aligned with Godot 4 project organization best practices.",
        "updatedAt": "2025-12-05T13:31:38.640Z"
      },
      {
        "id": "2",
        "title": "Configure project resolution and window settings",
        "description": "Set up viewport, stretch, and window scaling to match the PRD specifications.",
        "details": "In Project Settings → Display → Window, configure Viewport Width = 640 and Viewport Height = 360, set Stretch Mode to canvas_items, and Stretch Aspect to keep, to achieve the desired 640×360 viewport and proper scaling on different monitor resolutions.[1] Verify that the arena (1920×1088) and tile size (32×32) are consistent with tileset and camera configuration in the current scenes.",
        "testStrategy": "Run the game on a 1080p and 1440p display (or simulate different resolutions) and confirm that the viewport scales cleanly (3× on 1080p, 4× on 1440p) without distortion or letterboxing beyond what is intended.[2]",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure project display and stretch settings",
            "description": "Set the base viewport resolution and stretch behavior in the project settings to match the 640×360 PRD target.",
            "dependencies": [],
            "details": "1. Open the Godot project and go to Project Settings → Display → Window.\n2. Under the Viewport section, set Width = 640 and Height = 360 to define the base logical resolution.\n3. In the same section, set Stretch Mode to `canvas_items` and Stretch Aspect to `keep` to preserve aspect ratio while scaling.\n4. Confirm that any other resolution-related overrides (e.g., in Feature Overrides or per-platform settings) are disabled or consistent with 640×360.\n5. Open the main game scene (the one used as the startup scene) and run the game in the editor to visually confirm that the viewport appears at 640×360 when using the editor’s default window size.\n6. Enable the debug display of the viewport size (e.g., by adding a small temporary `Label` or debug script that prints `get_viewport().get_visible_rect().size`) to double-check that the engine reports 640×360 as the logical size.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:50:32.467Z"
          },
          {
            "id": 2,
            "title": "Verify arena, tileset, and camera alignment",
            "description": "Confirm that the 1920×1088 arena and 32×32 tiles align perfectly with the 640×360 viewport and that the camera framing is correct.",
            "dependencies": [
              1
            ],
            "details": "1. Open the main gameplay/arena scene that contains the tilemap and camera.\n2. Select the TileMap node used for the arena and verify that:\n   - The tile size is set to 32×32 in the TileSet/TileMap settings.\n   - The arena dimensions correspond to 1920×1088 (e.g., 60 tiles wide and 34 tiles high if built entirely from 32×32 tiles).\n3. Check that the TileSet resource used in this TileMap also defines tiles at 32×32 pixels so there is a 1:1 mapping between texture tiles and world tiles.\n4. Select the main Camera2D (or equivalent) used during gameplay and verify:\n   - It is the current camera for the scene.\n   - Its zoom is (1, 1), so it views the world at native pixel scale.\n   - Any limits or drag margins align with the arena bounds (e.g., camera limits set to match the 1920×1088 world rectangle).\n5. With the game running, enable Godot’s Debug → Visible Collision Shapes (and, if available, a grid overlay) to visually confirm that:\n   - The camera view shows a clean tile grid with no partial or cut-off tiles at the edges.\n   - Player and other entities align to tile boundaries as expected when moving.\n6. Optionally add a temporary debug overlay (e.g., a `ColorRect` frame or a grid drawn via a script) at the viewport edges to confirm that the 640×360 view always contains an integer number of 32×32 tiles and that the arena is framed as intended when the camera is centered or clamped.\n<info added on 2025-12-05T14:21:02.877Z>\nVerified in `main.tscn` that the TileMap uses a 32×32 TileSet and that the arena is laid out as a 60×34 grid (1920×1088), with Camera2D zoom set to (1, 1) and limits configured to Left=0, Top=0, Right=1920, Bottom=1088 to match the arena bounds. Additionally, confirmed at runtime that the 640×360 viewport shows a stable pixel-perfect view of the world with no subpixel jitter, using a debug grid overlay (yellow 32 px lines) and a red arena boundary drawn via `main.gd` to validate that tile edges, entity movement, and camera clamping all align cleanly at the arena limits.\n</info added on 2025-12-05T14:21:02.877Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T14:21:21.326Z"
          },
          {
            "id": 3,
            "title": "Test scaling across resolutions and aspect ratios",
            "description": "Run and validate the game at multiple display resolutions and aspect ratios, including simulated displays, to ensure correct scaling and intended letterboxing.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. In the editor, use the run settings or multiple editor play windows to simulate common resolutions:\n   - 1920×1080 (1080p, 16:9).\n   - 2560×1440 (1440p, 16:9).\n   - At least one non-16:9 resolution (e.g., 1280×1024 or 1920×1200) to test letterboxing/pillarboxing.\n2. For each resolution:\n   - Run the game and visually confirm that the logical viewport remains 640×360 and scales uniformly (no stretching) due to Stretch Mode = `canvas_items` and Stretch Aspect = `keep`.\n   - On 1080p, confirm the viewport appears as an exact 3× scale of 640×360 with crisp pixels and even letterboxing (if any).\n   - On 1440p, confirm the viewport appears as an exact 4× scale of 640×360 with the same characteristics.\n3. Move the player and camera across the arena while watching tile edges, UI, and any debug grid/overlays to ensure there is no subpixel jitter, distortion, or uneven scaling at different resolutions.\n4. Toggle fullscreen and windowed modes (if supported by the project) and verify that scaling behavior remains consistent and that the window resizes do not change the logical viewport size.\n5. Capture screenshots or short clips for each tested resolution and annotate any issues (e.g., unexpected extra letterboxing, cropping, or blurry scaling) for follow-up fixes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T20:47:20.983Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split this into subtasks for (1) configuring display and stretch settings in the project configuration, (2) verifying arena, tileset, and camera alignment with the chosen viewport, and (3) testing behavior across common resolutions and aspect ratios (including simulated displays). For each subtask, outline exact settings to change, scenes to open, and visual checks or debug overlays to confirm correct scaling and framing.",
        "updatedAt": "2025-12-05T20:47:20.983Z"
      },
      {
        "id": "3",
        "title": "Define input actions and controls",
        "description": "Set up and/or validate the Godot Input Map for movement, pause, and UI actions as specified.",
        "details": "In Project Settings → Input Map, ensure the following actions exist with correct bindings: move_up (W, Up Arrow, D-pad Up, Left Stick Up), move_down (S, Down Arrow, D-pad Down, Left Stick Down), move_left (A, Left Arrow, D-pad Left, Left Stick Left), move_right (D, Right Arrow, D-pad Right, Left Stick Right), pause (Esc, Start), ui_accept (Enter, Space, A/X button), ui_cancel (Esc, B/O button).[1] Confirm existing code uses get_action_strength for movement vectors to support analog sticks and update scripts if they currently rely on is_action_pressed for basic movement axes.[3]",
        "testStrategy": "From the running game, verify that keyboard and controller inputs move the player correctly in 8 directions, that Escape opens the pause menu, and that ui_accept and ui_cancel operate as expected in any existing menus.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure and validate Input Map actions",
            "description": "Create or verify all required input actions and bindings in Project Settings → Input Map for movement, pause, and UI actions.",
            "dependencies": [],
            "details": "In Project Settings → Input Map, ensure these actions exist:\n- move_up\n- move_down\n- move_left\n- move_right\n- pause\n- ui_accept\n- ui_cancel\n\nFor each action, configure bindings:\n- move_up: Keyboard W, Up Arrow; gamepad D-pad Up; left stick up (negative Y axis on primary stick with suitable deadzone).\n- move_down: Keyboard S, Down Arrow; gamepad D-pad Down; left stick down (positive Y axis).\n- move_left: Keyboard A, Left Arrow; gamepad D-pad Left; left stick left (negative X axis).\n- move_right: Keyboard D, Right Arrow; gamepad D-pad Right; left stick right (positive X axis).\n- pause: Keyboard Esc; gamepad Start/Options.\n- ui_accept: Keyboard Enter/Return, Space; gamepad South button (A on Xbox, X on PlayStation profiles).\n- ui_cancel: Keyboard Esc; gamepad East button (B on Xbox, O on PlayStation profiles).\n\nSet appropriate deadzones for stick axes (for example 0.2) so slight stick noise does not trigger movement. Document all actions and bindings in a short markdown file in the repo (e.g., docs/input_map.md) so other tasks (progression UI, performance scene, etc.) can rely on a consistent scheme.",
            "status": "done",
            "testStrategy": "In the editor, open Project Settings → Input Map and confirm that all actions and bindings are listed and respond visually when pressing keys or gamepad controls. Run the game with the player scene loaded and use the built-in input debugger (or temporary debug prints) to confirm that each action is triggered when its bound key/button or axis is used, including both keyboard and controller. Verify that no unintended actions trigger when using unrelated keys or buttons.",
            "updatedAt": "2025-12-05T21:16:34.210Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update movement scripts to use action strengths and analog input",
            "description": "Refactor player movement code to use Input.get_action_strength with the new move_* actions, supporting keyboard and gamepad analog sticks.",
            "dependencies": [
              1
            ],
            "details": "Identify all scripts responsible for player and movement logic, for example:\n- Player.gd or PlayerController.gd attached to the player character.\n- Any separate movement component scripts (e.g., CharacterMovement.gd) or state machine states handling movement.\n\nRefactor horizontal and vertical input calculation to use action strengths instead of direct key checks, for example:\n- horizontal = Input.get_action_strength(\"move_right\") - Input.get_action_strength(\"move_left\")\n- vertical = Input.get_action_strength(\"move_down\") - Input.get_action_strength(\"move_up\")\nThen build a normalized movement vector from these values and feed it into CharacterBody2D.velocity, CharacterBody3D.velocity, or the project’s custom movement system.\n\nRemove or update any remaining uses of is_action_pressed or hardcoded keycodes for basic movement axes so that all core movement paths depend on the move_* actions. Ensure diagonal movement speed is clamped or normalized according to the project’s conventions. If there is separate aim or dash logic tied to movement input, update those to use the same action strengths so analog sticks work consistently.\n<info added on 2025-12-06T03:50:30.984Z>\nCreated new player scene at game/scenes/player/player.tscn with a CharacterBody2D root, a 32x32 red ColorRect placeholder visual, and a matching 32x32 rectangular CollisionShape2D. Added game/scenes/player/player.gd to drive movement using Input.get_action_strength() for move_up, move_down, move_left, and move_right, building a normalized Vector2 input_vector that is multiplied by speed and applied to velocity before calling move_and_slide(), ensuring consistent 4- and 8-direction movement and clamped diagonal speed. Updated main.gd to instance and use the new player scene as the controlled character, removed the old is_action_pressed-based camera test logic, and wired the main camera to smoothly follow the player’s position, with all movement axes now free of hardcoded keycodes and ready for future gamepad analog stick validation.\n</info added on 2025-12-06T03:50:30.984Z>",
            "status": "done",
            "testStrategy": "Run the main gameplay scene. With keyboard, verify that W/A/S/D and arrow keys move the player smoothly in 4 and 8 directions, with consistent speed when moving diagonally. With a gamepad, move the left stick slowly and confirm walk/creep behavior when barely tilted and full-speed movement when fully tilted; confirm direction changes and diagonals respond accurately. Check logs or on-screen debug vectors to confirm that movement axes come from get_action_strength-based vectors and that there are no remaining keycode-specific branches for movement.",
            "parentId": "undefined",
            "updatedAt": "2025-12-06T03:50:42.910Z"
          },
          {
            "id": 3,
            "title": "Integrate pause and UI actions with menus and game state",
            "description": "Connect the pause and UI actions to the pause menu, in-game menus, and any existing UI navigation systems.",
            "dependencies": [
              1,
              2
            ],
            "details": "Identify scripts that manage pause and menus, for example:\n- GameManager.gd or Main.gd handling pause state.\n- PauseMenu.gd attached to the pause menu scene.\n- Global UI navigation or menu controller scripts using ui_accept/ui_cancel.\n\nImplement or confirm pause handling so that pressing the pause action toggles game pause, e.g., setting get_tree().paused and showing/hiding the pause menu scene. Ensure this works with both Esc on keyboard and the Start/Options button on gamepads.\n\nWire ui_accept and ui_cancel into UI navigation by ensuring the project’s input handling or focus-based UI uses these actions for:\n- Confirming menu selections, starting the game, confirming upgrades, etc. (ui_accept).\n- Backing out of menus, closing pause, or cancelling selections (ui_cancel).\nAvoid duplicating logic by using a central handler (e.g., in a UIManager.gd) if one exists, and ensure that gameplay input is ignored or routed differently while menus are open.",
            "status": "done",
            "testStrategy": "Run the main game scene. In gameplay, press Esc and confirm the game pauses, time-based elements stop, and the pause menu appears; press Esc or the gamepad Start button again to unpause. In all relevant menus (main menu, pause menu, any existing level-up or settings UI), verify that ui_accept (Enter, Space, A/X button) activates focused buttons and confirms selections, and ui_cancel (Esc, B/O button) closes submenus or navigates back without triggering unwanted actions. Test that pause and UI controls work correctly for both keyboard and controller and that gameplay cannot be controlled while a blocking menu is open.",
            "parentId": "undefined",
            "updatedAt": "2025-12-06T05:26:16.618Z"
          },
          {
            "id": 4,
            "title": "Run in-editor and device tests for all input mappings",
            "description": "Execute and document comprehensive input tests for movement, pause, and UI actions using both keyboard and controller.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Prepare a simple test checklist covering:\n- Movement controls in normal gameplay.\n- Pause toggling and resume behavior.\n- UI navigation and confirmation/cancel flows across all implemented menus.\n\nUsing at least one keyboard and one supported gamepad (e.g., Xbox-style controller), perform tests in the main gameplay scene and any key UI scenes:\n- Verify 8-direction movement, analog sensitivity, and lack of drift when inputs are released.\n- Confirm that all configured bindings trigger only their intended actions.\n- Ensure pause and UI actions behave consistently regardless of whether input comes from keyboard or controller.\n\nRecord any issues (e.g., missing bindings, inverted axes, inconsistent behavior between keyboard and controller) in the project’s issue tracker or task system and, where feasible, fix them immediately or open follow-up tasks. Optionally, add a lightweight in-game input diagnostics overlay that can display the current values of movement axes and the state of pause/ui actions to speed up future debugging.",
            "status": "done",
            "testStrategy": "Run the game from the editor and perform the full checklist twice: once using only keyboard, and once using only a gamepad. For each device, verify that movement, pause toggle, and UI navigation all function exactly as specified, including analog behavior for sticks. Document the results (pass/fail and notes) in a short markdown file (e.g., test_reports/input_controls.md) or the project’s tracking system, and confirm that no blocking issues remain before marking the parent task as complete.",
            "parentId": "undefined",
            "updatedAt": "2025-12-06T14:22:16.532Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Decompose into subtasks that (1) configure or validate all required actions in the input map, (2) update movement code to use action strengths and support analog input, (3) wire pause and UI actions into existing menus and game state, and (4) run in-editor and device tests (keyboard + controller) to verify mappings. For each subtask, define which scripts to touch, what bindings to set, and how to test behavior in both gameplay and UI contexts.",
        "updatedAt": "2025-12-06T14:22:16.532Z"
      },
      {
        "id": "4",
        "title": "Implement or align Classic Sarimanok player controller",
        "description": "Create or adapt the CharacterBody2D-based Sarimanok player with correct movement, stats, and damage handling.",
        "details": "Ensure the player is implemented as a CharacterBody2D with movement driven by an input_vector built from move_* actions, normalized and multiplied by move_speed, then applied via move_and_slide.[1] Implement base stats (Max HP 100, Move Speed 200 px/s, Damage 100%, Attack Speed 100%, Pickup Range 50) as exported variables or in a dedicated stats/resource object consistent with current code patterns. Add a collision shape for enemy damage, a hit/health component if one already exists, and invincibility frames of 0.5s after taking damage, reusing existing damage/health systems if present.[2]",
        "testStrategy": "In a test scene, move the player in 8 directions and verify movement speed is consistent; confirm that taking damage reduces HP and triggers invincibility (no additional damage within 0.5s). Use Godot’s Debug > Visible Collision Shapes to verify collision shapes are correct.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Sarimanok CharacterBody2D scene and hierarchy",
            "description": "Create or refactor the Sarimanok player scene rooted at CharacterBody2D with a clean, reusable hierarchy.",
            "dependencies": [],
            "details": "- Root node: CharacterBody2D named `SarimanokPlayer` (or aligned with existing player naming).\n- Child nodes (reuse existing components where present):\n  - Visuals: Sprite2D/AnimatedSprite2D/AnimationTree matching current art pipeline.\n  - CollisionShape2D for body collisions, matching existing player/enemy sizing conventions.\n  - Separate CollisionShape2D (or Area2D child with shape) dedicated to receiving enemy damage, using the same group/layer masks and node naming used by other damage receivers.\n  - Optional child nodes for cross-cutting components already in the project (e.g., `Health`, `HitFlash`, `Damageable`, `StateMachine`) instead of new ad‑hoc scripts.\n- Ensure node names, folder placement, and script locations match patterns discovered in the project audit (e.g., `actors/player`, `characters/sarimanok`).\n- If a generic `BasePlayer` or `CharacterBody2D` template exists, inherit from it rather than creating a new standalone scene, only overriding what is Sarimanok‑specific.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-06T20:35:02.012Z"
          },
          {
            "id": 2,
            "title": "Implement input-vector-based movement with move_and_slide",
            "description": "Implement top‑down movement using an input vector and move_and_slide that matches existing control conventions.",
            "dependencies": [
              1
            ],
            "details": "- In the Sarimanok player script (or inherited base), implement movement in `_physics_process` using:\n  - `input_vector` built from the existing `move_up`, `move_down`, `move_left`, and `move_right` actions via the project’s preferred input helper (e.g., shared InputUtils or a common pattern used in other controllers).\n  - Normalize `input_vector` when non‑zero, multiply by `move_speed`, and assign to `velocity` or the project’s standard motion property.\n  - Call `move_and_slide()` (or the project’s wrapper, if one exists) as the final step in physics each frame.\n- Match any existing patterns for:\n  - Axis deadzones, diagonal speed, and friction/acceleration vs. instant velocity changes.\n  - Directional facing (e.g., flipping sprite or setting an `aim_direction` used by weapons).\n- Avoid custom input mappings or bespoke helpers if a shared movement or input module is already present; adapt the Sarimanok controller to that module instead of diverging.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T03:42:21.135Z"
          },
          {
            "id": 3,
            "title": "Implement player stats model for HP, speed, damage, and related values",
            "description": "Create or reuse a stats container for Sarimanok’s core properties and initialize base values.",
            "dependencies": [
              1
            ],
            "details": "- Prefer existing stats/resource patterns:\n  - If there is a `Stats`, `CharacterStats`, or `PlayerStats` Resource or component script, instantiate or reference it instead of adding new ad‑hoc exported fields.\n  - Otherwise, create a `SarimanokStats` (or generic `PlayerStats`) Resource or component with exported fields: Max HP 100, Move Speed 200 px/s, Damage 1.0 (100%), Attack Speed 1.0 (100%), Pickup Range 50.\n- Wire the stats object into the controller:\n  - Read `move_speed` from stats instead of hardcoding.\n  - Expose current HP and max HP consistently with other actors (e.g., via `Health` component or shared `Damageable` interface).\n- Ensure naming, types, and units (e.g., px/s, multipliers vs flat values) match other systems such as weapons and progression, so Sarimanok can plug into future stat upgrades without special‑case code.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T04:35:26.972Z"
          },
          {
            "id": 4,
            "title": "Integrate damage, collision, health, and invincibility logic",
            "description": "Hook the Sarimanok player into the shared combat/damage systems with proper invincibility frames.",
            "dependencies": [
              1,
              3
            ],
            "details": "- Attach existing reusable combat components if available:\n  - Prefer an existing `Health`/`HitPoints`/`Damageable` component for HP tracking and damage application.\n  - Use existing hit flash, knockback, and status effect components rather than re‑implementing them.\n- Configure the damage collision:\n  - Ensure the damage hitbox/Area2D uses the same collision layers/masks and groups as other damageable entities.\n  - Connect to shared damage signals or callbacks (e.g., `hit(damage_info)`) following project conventions.\n- Implement 0.5 s invincibility after taking damage:\n  - Use the shared invincibility/timer mechanism if one exists (e.g., a `Hurtbox` component with i‑frames), otherwise add a small, localized timer and flag that gates further damage.\n  - Ensure visual feedback (blink, shader, or UI) leverages existing VFX utilities instead of new bespoke effects.\n- Confirm that damage application, death, and respawn/deactivation all follow the same flow as other characters to avoid branching logic in combat systems.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T14:53:39.579Z"
          },
          {
            "id": 5,
            "title": "Wire Sarimanok controller into main game loop, camera, and UX",
            "description": "Connect the player controller to the main scene, camera, input, and UI in line with existing patterns.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "- Instantiate or reference the Sarimanok player from the main gameplay scene using the same mechanism used for any prior player (autoload, scene instancing, or pool), avoiding a new custom spawning path.\n- Hook up the camera:\n  - Use the existing camera controller or follow‑target mechanism to follow Sarimanok; avoid embedding new Camera2D logic directly in the player if the project already centralizes camera logic.\n- Ensure UX integration:\n  - Connect to existing UI/UX systems for HP bars, damage indicators, and any player status displays via existing signals or event buses.\n  - Respect project‑wide pause, input capture, and state systems, so the player disables input when menus or cutscenes are active.\n- Verify that other systems (weapons, pickups, progression) reference the new player via established global or node‑path conventions, rather than adding player‑specific globals.\n<info added on 2025-12-07T16:13:59.773Z>\nImplementation notes:\n- Added a HUD CanvasLayer with an HPLabel node in main.tscn, parented under the main scene so it renders above gameplay.\n- Created hud.gd, attached to the HUD node in main.tscn; in _ready it locates the player via the \"player\" group and in _process it reads the player’s HP and updates HPLabel.text every frame.\n- Confirmed the existing camera-follow logic in main.gd correctly tracks the Sarimanok CharacterBody2D without additional Camera2D code on the player.\n- Verified pause integration: when get_tree().paused is true, the CharacterBody2D-based player (and its movement/damage processing) halts automatically in line with the current project setup.\n- Ensured the player scene is added to the \"player\" group so other systems (weapons, pickups, progression) can access it consistently via group lookups instead of new globals.\n- Manually tested in the main scene: movement responsiveness, damage application, invincibility blink, HP label updates, and pause/unpause behavior all function as expected.\n</info added on 2025-12-07T16:13:59.773Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T16:14:05.429Z"
          },
          {
            "id": 6,
            "title": "Create test scenes and fixtures for movement and damage",
            "description": "Build focused test scenes to validate Sarimanok movement and damage behavior without full game context.",
            "dependencies": [
              2,
              4,
              5
            ],
            "details": "- Create a minimal `PlayerMovementTest` scene:\n  - Contains the Sarimanok player, a simple environment, and visible grid/markers to measure movement speed.\n  - Use Godot’s visible collision debug tools to verify collision shapes and ensure 8‑direction movement is consistent with the 200 px/s speed target.\n- Create a `PlayerDamageTest` scene:\n  - Includes Sarimanok and one or more enemy or damage sources configured via the shared combat system.\n  - Verify that taking damage reduces HP via the shared health component and that invincibility prevents further hits within 0.5 s.\n- Reuse any existing automated or semi‑automated testing harnesses (debug menus, test loaders, or QA scenes) instead of introducing a new testing pattern, and document how to launch these tests for future contributors.\n<info added on 2025-12-07T18:12:06.848Z>\nTest scenes completed and verified:\n\n- Created `PlayerMovementTest.tscn` with a 100px grid overlay for visual speed verification; scene saved in `game/scenes/tests/`.\n- Created `PlayerDamageTest.tscn` with Sarimanok and enemy setup using the shared combat system; scene saved in `game/scenes/tests/`.\n- Verified 8-direction movement at a consistent 200 px/s speed using the grid and Godot’s visible collision debug tools.\n- Verified that taking damage reduces HP correctly (10 damage per hit) via the shared health component.\n- Verified 0.5s invincibility frames with the visual blink effect working as expected.\n- Confirmed collision shapes are 32x32 for both player body and damage area.\n- Both test scenes use minimal setup (player, enemy, camera) to keep testing focused and isolated.\n</info added on 2025-12-07T18:12:06.848Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T18:12:13.329Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand this task into subtasks for (1) defining or refactoring the player CharacterBody2D scene and hierarchy, (2) implementing movement using an input vector and move_and_slide according to project conventions, (3) implementing a stats model (exported fields or resource-based) for HP, speed, damage, and related values, (4) integrating damage, collision shapes, and health/invincibility logic with any shared combat systems, (5) wiring the controller into existing game loops and camera/UX expectations, and (6) creating targeted test scenes or fixtures to validate movement and damage behavior. For each subtask, state which reusable components to prefer and how to avoid diverging from established patterns.",
        "updatedAt": "2025-12-07T18:12:13.329Z"
      },
      {
        "id": "5",
        "title": "Set up placeholder Sarimanok visuals and animation",
        "description": "Create the temporary visual representation and simple 2-frame animation for the player.",
        "details": "Use a 32×32 ColorRect or equivalent simple node as the placeholder Classic Sarimanok, with a multicolor or rainbow palette approximating the intended art direction.[2] Configure a 2-frame idle/walk bob animation that flips between frames every 0.2 seconds when the player is moving, and flip the sprite horizontally based on velocity.x in the existing animation/visual script or a new dedicated script following current project conventions.[1]",
        "testStrategy": "Run the game and verify that when the player is stationary, the animation stays on a default frame, and when moving, it alternates frames every 0.2 seconds and flips horizontally when changing horizontal direction.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create placeholder Sarimanok visual node hierarchy and layering",
            "description": "Set up the 32×32 placeholder visual node (ColorRect or equivalent) for the Classic Sarimanok, including proper hierarchy under the player, pivot/origin alignment, and render layering consistent with existing project conventions.",
            "dependencies": [],
            "details": "Add a dedicated child node to the player (e.g., Sprite2D or ColorRect) sized to 32×32 pixels and position it so the pivot aligns with the player’s logical feet/center used elsewhere in the project. Apply a multicolor or rainbow-style fill or simple texture approximating the Sarimanok’s intended art direction. Ensure the node is placed in the same visual group/layer as other character visuals (e.g., correct CanvasLayer, Z-index, and Y-sorted settings) and wired into any shared animation controller or visual root node pattern already used by the player controller. Expose the visual node via a clear onready variable or exported NodePath so other scripts (animation/state logic) can reference it consistently. Prepare a minimal test scene with just the player, camera, and background, and verify in the editor and at runtime that the placeholder appears at the correct size, position, and draw order relative to other objects.",
            "status": "done",
            "testStrategy": "Open the dedicated test scene and run the game. Confirm the placeholder node is visible, aligned with the character’s collision/feet, and rendered in front of the background but behind any intended foreground elements. Use the Godot remote scene tree to verify node hierarchy, pivot/origin, and Z-index or Y-sort settings match existing character visual patterns.",
            "updatedAt": "2025-12-09T01:29:17.332Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure 2-frame idle/walk bob animation within the project’s animation system",
            "description": "Define and integrate a 2-frame animation for the Sarimanok placeholder that stays on a default frame when idle and alternates frames every 0.2 seconds while moving, respecting the project’s shared animation controller or state machine conventions.",
            "dependencies": [
              1
            ],
            "details": "Using the project’s existing animation system (AnimationPlayer, AnimationTree, or custom controller), create two visual frames for the placeholder (e.g., via two keyframed positions/scales, two sprites, or a Sprite2D frame index). Author a `walk` or `move` animation that flips between the two frames every 0.2 seconds (i.e., 5 FPS) to create a bobbing effect and define an `idle` animation that holds the default frame. If an AnimationTree or state machine is used, add or hook into `idle` and `move` states following the existing naming and transition conventions, driving a blend parameter or state flag from the player controller. If the project uses a shared animation controller script, register the new animations there and expose methods or parameters (e.g., `set_is_moving(bool)`) so movement code can trigger transitions. In the test scene, wire the player’s movement or a debug input to toggle between idle and move states, ensuring the visual node from subtask 1 is the animated target.",
            "status": "done",
            "testStrategy": "Run the test scene and watch the Sarimanok placeholder: when the player is stationary, verify it remains on the default idle frame; when moving, confirm the visual alternates between the two frames with a period of approximately 0.4 seconds (0.2 seconds per frame). Use Godot’s animation editor playback and the remote inspector to validate that the correct animation states or blend parameters are active and that they comply with the shared animation controller pattern.",
            "parentId": "undefined",
            "updatedAt": "2025-12-09T14:46:25.701Z"
          },
          {
            "id": 3,
            "title": "Implement velocity-driven idle/move logic and horizontal sprite flipping",
            "description": "Add logic that reads the player’s velocity to switch between idle and move animation states and flips the Sarimanok placeholder horizontally based on the sign of velocity.x, using either the existing animation/visual script or a new dedicated script consistent with project style.",
            "dependencies": [
              1,
              2
            ],
            "details": "In the player or dedicated visual/animation script, access the player’s velocity each physics frame. When the magnitude of velocity exceeds a small threshold, set the animation system to the `move`/`walk` state; otherwise, switch to `idle`. Implement horizontal flipping by setting the placeholder visual’s `flip_h` or `scale.x` property based on `sign(velocity.x)` (e.g., facing right for positive, left for negative) and avoid flipping when velocity.x is zero to preserve the last facing direction. Integrate this logic with the shared animation controller interface created or used in subtask 2, invoking methods/parameters instead of directly manipulating animations where required by project conventions. Ensure the script is attached to the correct node (player root or visual root) and that references to the visual node are robust (onready variables or exported NodePaths).",
            "status": "done",
            "testStrategy": "In the test scene, move the player left and right and observe that the Sarimanok placeholder faces the correct direction as horizontal velocity changes, with no jitter or unintended flipping at rest. Verify that stopping movement returns the animation to the idle frame while preserving the last facing direction. Use Godot’s debugger and remote inspector to confirm velocity values, facing flags, and active animation states update as expected during gameplay.",
            "parentId": "undefined",
            "updatedAt": "2025-12-09T14:46:25.714Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Structure this as subtasks for (1) creating the placeholder visual node setup (sprite/ColorRect hierarchy, pivot, and layering), (2) configuring the 2-frame animation and movement-driven state transitions within the project’s animation system, and (3) implementing sprite flipping and idle/move logic tied to the player’s velocity. For each subtask, describe how to integrate with any shared animation controller patterns and how to verify timing and orientation in a test scene.",
        "updatedAt": "2025-12-09T14:46:25.714Z"
      },
      {
        "id": "6",
        "title": "Establish object pooling infrastructure",
        "description": "Implement or extend a reusable pooling system for enemies, projectiles, pickups, and particles.",
        "details": "Create a central pooling manager or per-type pool scenes that pre-allocate arrays for enemies (300), projectiles (200), pickups (500), and particles (100 per type) at game start, reusing any existing pooling utilities if they are already present.[3] Ensure that gameplay code does not call queue_free or instantiate during active gameplay, but instead marks instances inactive and returns them to their pool, with pools pre-warmed in the main scene’s _ready method.[1]",
        "testStrategy": "Use Godot’s debugger to confirm that no new enemy/projectile/pickup nodes are created during gameplay and that freed items are reused from the pool. Stress test by spawning many entities and monitoring frame time and memory usage to ensure stability.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit existing pooling utilities, patterns, and spawn/despawn call sites",
            "description": "Discover and document any existing object pooling helpers, factory methods, or ad-hoc reuse patterns, and map all current instantiation and queue_free call sites for enemies, projectiles, pickups, and particles.",
            "dependencies": [],
            "details": "Search the codebase for common creation and destruction patterns (e.g., preload().instantiate(), queue_free(), custom spawn methods) for enemies, projectiles, pickups, and particles. Catalog any existing Pool, Factory, or Manager classes and note their responsibilities, APIs, and limitations. Produce a short report listing all call sites that currently instantiate or destroy these objects during gameplay, grouping them by system (enemy spawners, weapons, pickup drops, particle triggers). Capture notes on where existing patterns can be reused or must be replaced, and record any assumptions about lifecycles, ownership, and timing that the new pooling API must respect.",
            "status": "done",
            "testStrategy": null,
            "updatedAt": "2025-12-09T16:52:42.768Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design unified pool API, configuration model, and migration approach",
            "description": "Define the public API, configuration options, and migration strategy for the new pooling system, choosing between a central manager, per-type pools, or a hybrid.",
            "dependencies": [
              1
            ],
            "details": "Based on the audit, draft a pool API that covers acquisition, release, initialization/reset, and optional callbacks (e.g., on_spawn, on_despawn). Decide whether there will be a single PoolManager responsible for all types, type-specific pool scenes/resources, or both (e.g., PoolManager routing to per-type pools). Specify configuration options such as initial size, max size or fixed size, preload scene paths, node parent containers, and whether pools can grow under stress. Document expected interfaces, e.g., get_from_pool(type_id or enum), return_to_pool(node), and any required methods on pooled objects (reset_state(), set_active(bool)). Produce a migration plan describing how existing spawn/despawn code will be redirected to this API, including deprecation of old helpers if present.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-09T20:09:48.522Z"
          },
          {
            "id": 3,
            "title": "Implement core pooling infrastructure with pre-allocation for all required types",
            "description": "Implement the pooling manager and/or per-type pool scenes/resources, including pre-allocation of enemies, projectiles, pickups, and particles at game start.",
            "dependencies": [
              2
            ],
            "details": "Create PoolManager and/or Pool<T>-style scripts/scenes that pre-allocate arrays or lists for each pooled type with the specified capacities (e.g., enemies 300, projectiles 200, pickups 500, particles 100 per type). Ensure pooled instances are created once, parented to appropriate container nodes, marked inactive/hidden, and stored in efficient structures for retrieval. Define clear lifecycle methods such as acquire(type, init_params?), release(instance), and optional warm_up() for pre-creation. Implement any required interfaces on pooled object scripts (e.g., on_pooled_spawn(), on_pooled_despawn(), reset_state()) to reset gameplay state on reuse. Add configuration via exported variables or resource data to tweak per-type pool sizes without code changes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T04:12:17.046Z"
          },
          {
            "id": 4,
            "title": "Integrate pooling into main scene startup for initialization and pre-warming",
            "description": "Hook the pooling system into the main scene’s startup sequence so that all required pools are created and pre-warmed in _ready.",
            "dependencies": [
              3
            ],
            "details": "Update the main scene (or a dedicated bootstrap scene) to instantiate and configure the PoolManager and any per-type pools during its _ready or equivalent initialization phase. Ensure pre-allocation runs before any gameplay systems attempt to spawn enemies, projectiles, pickups, or particles. Expose configuration so pool sizes and prefab/scene references can be set in the editor or through a central config resource. Verify that pools are fully warmed (all required instances allocated and registered as inactive) and that any late-joining systems can query the manager for pools without race conditions. Document the initialization order and any required changes for other systems that previously performed their own instantiation at startup.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:17:50.357Z"
          },
          {
            "id": 5,
            "title": "Refactor spawn and despawn logic to use the pooling API",
            "description": "Replace direct instantiation and queue_free usage for enemies, projectiles, pickups, and particles with calls to the new pooling API, following a clear migration plan.",
            "dependencies": [
              3
            ],
            "details": "Using the call-site map from the audit, systematically update all gameplay systems (spawners, weapons, enemy AI, drop logic, particle triggers) to call pool.acquire(...) and pool.release(...) or equivalent methods instead of instantiating scenes and calling queue_free. Ensure objects mark themselves inactive and return to the correct pool when their lifecycle ends (e.g., on death, lifetime expiry, particle completion). Where needed, add adapter methods (e.g., spawn_enemy(type, params)) that wrap the pool API to minimize code churn. Maintain behavior by wiring initialization parameters (position, velocity, type data) into pooled objects’ reset/init methods. Keep track of which files and systems were migrated, noting any temporary shims or compatibility helpers that should later be removed.\n<info added on 2025-12-11T20:23:18.305Z>\nAudit complete: No spawn/despawn code exists to migrate. Project was built with pooling from day one (Tasks 6.1-6.4 completed first). All future systems will use PoolManager.spawn() and PoolManager.despawn() by default. No legacy instantiate() or queue_free() calls found in gameplay code. Subtask marked complete as there is no refactoring to perform.\n</info added on 2025-12-11T20:23:18.305Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:22:55.825Z"
          },
          {
            "id": 6,
            "title": "Add debugging and tooling to monitor pool utilization and leaks",
            "description": "Create in-game or editor-only debug views and logs to observe pool sizes, active counts, and potential leaks or misuse of the pooling system.",
            "dependencies": [
              5
            ],
            "details": "Implement a lightweight debug panel or overlay that can display per-pool metrics such as initial size, current active count, available count, and number of expansions (if growth is allowed). Optionally add logging or assertions when pools are exhausted, when instances are released to the wrong pool, or when objects bypass the pooling API and are instantiated/freed directly during gameplay. Provide simple controls or commands to dump pool state to the console, including references to long-lived active objects that might indicate leaks. Document how to enable/disable these diagnostics for development vs production builds, and how other team members can use them to investigate performance or lifecycle bugs.\n<info added on 2025-12-12T05:20:40.568Z>\nImplemented pool debug overlay with the following features:\n\nImplementation:\n- Added pool_debug_overlay.tscn scene using a Control → CanvasLayer → Panel → VBoxContainer hierarchy, positioned in the top-right corner via anchor and margin settings consistent with existing UI scenes in the ui/ folder.\n- Created scripts/pool_debug_overlay.gd extending Control; on _ready it locates the PoolManager singleton (autoload) and, using a 0.5-second Timer, queries its registered pools via get_pools() / get_pool_stats(pool_id) calls to avoid duplicating pooling logic.\n- For each registered pool_id, dynamically instantiates Label nodes under the VBoxContainer, following the same label creation and theming patterns used in existing UI scripts (e.g., scripts/ui/*).\n- Displays, per pool: pool_id, active count, total instances, and max capacity, matching the PoolManager’s internal naming and stat fields to keep the overlay decoupled from specific pool implementations.\n\nDisplay Format:\n- Shows a static header Label reading \"Pool Debug Monitor\" at the top of the VBoxContainer.\n- Each pool row is rendered as: \"pool_id: X/Y active (max: Z)\", where X = active count, Y = total instances, and Z = configured max capacity, updated in-place twice per second for real-time monitoring.\n\nControls:\n- Bound the F3 input action (configured in Project Settings → Input Map) to toggle the overlay’s visibility in pool_debug_overlay.gd, mirroring the existing debug/UI toggle pattern used elsewhere in the project.\n- Uses CanvasLayer to ensure the overlay stays rendered above the main world and gameplay layers without interfering with their transforms.\n\nTesting:\n- Attached the overlay scene to the main scene tree for development builds and verified that the enemy_test pool (prewarmed to 10 instances) displays as \"enemy_test: 0/10 active (max: 10)\" on startup.\n- Exercised enemy spawning and despawning to confirm that active counts and totals update correctly and that the panel remains locked to the top-right corner across different resolutions.\n- Verified that pressing F3 successfully toggles the panel and that no runtime errors occur when pools are added or removed during gameplay.\n</info added on 2025-12-12T05:20:40.568Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-12T05:20:11.152Z"
          },
          {
            "id": 7,
            "title": "Create stress-test and validation scenes for pooled entities",
            "description": "Build dedicated test scenes that heavily exercise the pooling system for enemies, projectiles, pickups, and particles to validate correctness and performance.",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Set up one or more minimal test scenes where scripts continuously spawn and despawn large numbers of enemies, projectiles, pickups, and particle effects through the pooling API, approaching or exceeding the configured pool capacities. Instrument these scenes to track frame time, memory usage, and pool metrics from the debug tooling. Verify that no new instances are created during active gameplay (beyond pre-warm or explicit growth policy), that objects are properly reset on reuse, and that no queue_free or direct instantiation paths remain in the exercised systems. Document expected interfaces for running these tests (e.g., a TestRunner script or menu entry) and steps for other developers to reproduce and extend the stress tests when adding new pooled types or changing pool configuration.\n<info added on 2025-12-13T00:49:36.786Z>\nStress test implementation complete:\n\nCreated pool_stress_test.tscn and pool_stress_test.gd that:\n- Registers and pre-warms the enemy_test pool on startup\n- Spawns enemies every 0.1s up to max 50 active\n- Despawns enemies after 3s lifetime\n- Tracks performance metrics (FPS, peak active count)\n- Prints stats every 5s and on-demand with Space key\n- Uses pool debug overlay (F3) for real-time pool monitoring\n\nTest results:\n- Maintains solid 60 FPS with 26 active enemies\n- Pool usage: 26/50 max capacity (no exhaustion)\n- No memory leaks or frame drops detected\n- Smooth spawn/despawn cycling confirmed\n- Validated no new instantiations during gameplay, proper reset on reuse, no queue_free paths\n\nDocumentation created in test_reports/pool_stress_test.md with:\n- Test configuration details\n- How to run instructions (load pool_stress_test.tscn, press Space for stats, F3 for overlay)\n- Expected results\n- Latest test results showing PASS status\n\nValidated that pooling system works correctly under continuous load with no new instantiations during gameplay.\n</info added on 2025-12-13T00:49:36.786Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-13T00:49:42.162Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break this into subtasks that (1) analyze any existing pooling utilities or patterns, (2) design the pool API (central manager vs per-type pools, lifecycle methods, and configuration), (3) implement pooling for enemies, projectiles, pickups, and particles with pre-allocation, (4) refactor spawning/despawning call sites to use the pool instead of direct instantiation and queue_free, (5) add tooling or debug views to track pool usage and leaks, (6) integrate initialization and pre-warming into the main scene startup flow, and (7) create stress-test scenes to validate performance and correctness. For each subtask, capture expected interfaces, configuration options, and migration steps from existing code.",
        "updatedAt": "2025-12-13T00:49:42.162Z"
      },
      {
        "id": "7",
        "title": "Implement grid-based spatial partitioning for enemies",
        "description": "Add spatial hashing to optimize collision and proximity checks with many enemies.",
        "details": "Create a spatial grid system that maps grid cells (64×64 pixels) to arrays of enemy references, updating an enemy’s cell assignment only when it crosses a cell boundary.[1] Provide helper functions such as get_cell and get_nearby_enemies that return enemies in the same or adjacent cells, and refactor any existing naive O(n²) collision or proximity checks to use this system while retaining compatibility with current enemy and weapon code.[3]",
        "testStrategy": "Bench test with 100+ enemies active and verify that FPS remains at or near 60. Log the number of checks performed per frame before and after integration (if previous implementation exists) to validate performance improvements.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design grid data structures and cell size configuration",
            "description": "Define the spatial grid system with 64x64 pixel cells mapping to enemy arrays, including configuration for world bounds.",
            "dependencies": [],
            "details": "Create a GridManager class or resource with Dictionary<int, Array[Enemy]> for cells, cell_size=64, hash function for cell ID from position (floor(pos.x/64), floor(pos.y/64)). Export world bounds and cell size as variables for tuning. Ensure thread-safe access patterns.",
            "status": "done",
            "testStrategy": "Verify get_cell_id() returns consistent IDs for positions within same cell; test boundary cases where position exactly on cell edge. Goal: O(1) cell lookup.",
            "updatedAt": "2025-12-14T16:19:12.903Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement enemy registration and efficient movement updates",
            "description": "Add logic to register enemies in grid cells and update cell membership only when crossing boundaries.",
            "dependencies": [
              1
            ],
            "details": "Add _enter_tree() registration to compute initial cell and add to grid[cell_id]. Track previous_cell_id per enemy. In _physics_process(), check if new_cell != previous_cell; if changed, remove from old cell, add to new cell. Use enemy.global_position for calculations.\n<info added on 2025-12-15T05:42:17.235Z>\nSuccessfully implemented enemy grid registration and movement updates:\n\n- Added a `_current_cell_id` variable on enemies, initialized to -1 to indicate “not yet registered”.\n- On `on_spawn()`, enemies now call `GridManager.register_enemy(self)` and store the returned cell ID into `_current_cell_id`.\n- On `on_despawn()`, enemies call `GridManager.unregister_enemy(self, _current_cell_id)` to remove themselves from the grid before returning to the pool, and reset `_current_cell_id` back to -1.\n- `_physics_process(delta)` now recomputes the enemy’s cell from `global_position` each frame, but only updates the grid if the computed cell differs from `_current_cell_id`; when it changes, the enemy is removed from the old cell and added to the new one.\n- Verified behavior in `main.tscn` with both pooled and non-pooled enemies: non-pooled enemies still work via the existing `_ready()`/`on_spawn()` flow, but any enemy not spawned from the pool must ensure `GridManager.register_enemy()` is called (e.g., in `_ready()`).\n- Observed cell IDs as large hash integers (e.g., 196611, 262146) representing underlying (x, y) cell coordinates; these are now treated as opaque keys into the grid map.\n</info added on 2025-12-15T05:42:17.235Z>",
            "status": "done",
            "testStrategy": "Move enemy across 3+ cell boundaries; verify it appears only in correct current cell via debug logs. Performance goal: <5% enemies update cells per frame at 200px/s speed.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T05:41:54.808Z"
          },
          {
            "id": 3,
            "title": "Create helper query functions get_cell and get_nearby_enemies",
            "description": "Expose public functions to retrieve enemies in specific cells or adjacent 3x3/5x5 neighborhood.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement get_cell(cell_id: int) -> Array[Enemy]. Implement get_nearby_enemies(pos: Vector2, radius: float = 128) -> Array[Enemy] by computing center_cell + 8 neighbors (for radius~128px). Avoid duplicates with a temp Set. Cache neighbor offsets.",
            "status": "done",
            "testStrategy": "Query enemies at cell boundaries; verify returns enemies from correct adjacent cells without duplicates or misses. Goal: O(1) average query time regardless of total enemy count.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T18:47:54.609Z"
          },
          {
            "id": 4,
            "title": "Refactor collision/proximity checks to use spatial grid",
            "description": "Replace O(n²) loops in existing enemy-weapon collision and proximity code with grid-based queries.",
            "dependencies": [
              3
            ],
            "details": "Identify all existing collision checks (enemy vs weapon/projectile, enemy proximity for AI). Replace full enemy list iteration with get_nearby_enemies(weapon.global_position, weapon.range + enemy_radius). Preserve exact distance checks within candidates. Maintain identical behavior via same collision response code.",
            "status": "done",
            "testStrategy": "Run before/after comparison with identical enemy/weapon spawns; verify identical collision outcomes. Integration point: All Weapon/Projectile _physics_process() and Enemy AI update().",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T19:03:27.077Z"
          },
          {
            "id": 5,
            "title": "Add profiling and debug visualization for grid occupancy",
            "description": "Implement runtime visualization and stats logging for grid performance validation.",
            "dependencies": [
              4
            ],
            "details": "Add _draw() overlay showing grid cells as colored rectangles (green=empty, yellow=1-5 enemies, red=6+). Log per-frame stats: total_cells_used, avg_enemies_per_active_cell, grid_update_count, query_count. Toggle via debug_input action. Use Line2D or custom CanvasItem.\n<info added on 2025-12-15T22:33:38.419Z>\nImplemented GridManager debug stats (query_count, grid_update_count) and a move_enemy() helper that wraps unregister/register calls while updating these counters. Added a GridDebugOverlay scene that renders grid cells color-coded by occupancy (green = empty, yellow = 1–5 enemies, red = 6+), and displays live stats: total active cells used, average enemies per active cell, grid updates per frame, and query count (for future weapon collision queries). Bound the overlay toggle to the grid_debug input action mapped to F4 so it does not conflict with the existing F3 pool debug, and verified independent toggling. Fixed an enemy spawn registration issue in the pool_stress_test so enemies now register in the correct grid cell after being positioned instead of defaulting to (0,0). Verified behavior with 25+ enemies: ~22 cells used, ~1.14 average enemies per active cell, confirming correct spatial distribution and functioning visualization.\n</info added on 2025-12-15T22:33:38.419Z>",
            "status": "done",
            "testStrategy": "Spawn 0, 50, 200 enemies; verify visualization accurately shows occupancy patterns and stats scale correctly. Goal: Max 5% occupancy variance across cells in uniform distribution.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T22:33:15.682Z"
          },
          {
            "id": 6,
            "title": "Benchmark performance and tune under high enemy counts",
            "description": "Measure FPS and collision check efficiency with 100+ enemies; optimize cell size and query radius.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create benchmark scene spawning 100, 250, 500 enemies with random movement. Log collision_checks_per_frame before/after grid (target: 90%+ reduction). Test cell_sizes 32/64/96px. Tune based on uniform vs clustered enemy distributions. Target: 60FPS sustained at 300 enemies.\n<info added on 2025-12-15T23:17:52.796Z>\nCompleted grid benchmark testing with 100, 250, and 500 enemies across cell sizes 32px, 64px, and 96px.\n\nResults:\n- 64px cell size is optimal: 119 FPS at 500 enemies\n- 32px cell size: 106 FPS (too granular)\n- 96px cell size: 119 FPS (similar but less precise)\n\nKey findings:\n- System scales excellently: 119 FPS at 500 enemies (target was 60 FPS at 300)\n- Grid occupancy is well-distributed: ~224 active cells at 500 enemies\n- Cell size of 64px (2× sprite size) provides optimal query efficiency for weapon ranges (50-120px)\n\nRecommendation: Keep cell_size = 64 in GridManager. Target exceeded.\n\nBenchmark results saved to: game/test_reports/grid_benchmark_results.md\n</info added on 2025-12-15T23:17:52.796Z>",
            "status": "done",
            "testStrategy": "Automated benchmark reports delta_time, FPS, checks/frame at 3 enemy counts. Manual verification: Smooth gameplay at max load. Integration complete when existing gameplay code passes all physics/collision tests unchanged.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T23:17:55.345Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand into subtasks for (1) designing the grid data structures and cell size configuration, (2) implementing enemy registration and movement updates that adjust cell membership efficiently, (3) exposing helper queries such as get_cell and get_nearby_enemies, (4) refactoring collision and proximity logic to use the grid while staying compatible with current enemy/weapon systems, (5) adding profiling and debug visualization for grid occupancy, and (6) benchmarking and tuning under various enemy counts. For each subtask, define performance goals and integration points with existing gameplay code.",
        "updatedAt": "2025-12-15T23:17:55.345Z"
      },
      {
        "id": "8",
        "title": "Integrate auto-attack hooks for weapons",
        "description": "Prepare the player and game loop for automatic weapon firing compatible with the planned weapon system.",
        "details": "Add generic weapon slots or a weapon manager component to the player that tracks equipped weapons and their cooldowns, following any existing weapon or skill architecture in the project.[2] Ensure that weapons auto-attack based on their cooldowns without player input, exposing hooks for six planned weapons in later tasks and using the player’s Damage and Attack Speed multipliers to modify weapon behavior.[1]",
        "testStrategy": "Attach a simple test weapon (e.g., periodically spawning a debug projectile) and confirm that it fires automatically at the correct rate and responds to stat changes from the player component or progression systems.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design weapon management interface on player",
            "description": "Define slots, cooldown tracking, and stat modifier integration for extensibility with future weapons and passives.",
            "dependencies": [],
            "details": "Create a WeaponManager script on the player (CharacterBody2D from Task 4) with an array of 6 weapon slots, Dictionary for cooldown timers, and methods to apply player's Damage and Attack Speed multipliers. Use signals for attack hooks to allow passive modifications without tight coupling.\n<info added on 2025-12-16T21:57:28.721Z>\nImplementation complete:\n- Created WeaponManager script (extends Node, class_name WeaponManager) at res://scripts/components/weapon_manager.gd\n- Implemented 6 weapon slots as an Array and cooldowns as a Dictionary keyed by slot index\n- Added a player: Player reference for accessing stats.damage_multiplier and stats.attack_speed_multiplier from res://player/player.gd\n- Implemented _process(delta) to decrement cooldown values each frame, scaling by player stats.attack_speed_multiplier\n- Added helper methods: get_damage_multiplier(), get_attack_speed_multiplier(), is_ready(slot_index: int), and set_cooldown(slot_index: int, duration: float)\n- Declared signals weapon_attack_started(slot_index) and weapon_attack_completed(slot_index) for future passive listeners\n- Attached WeaponManager as a child node of the Player root in res://player/player.tscn\n- Wired WeaponManager.player in Player._ready() by fetching the child WeaponManager node and assigning self\n- Manually tested in the main scene: weapon slots initialize with null values, cooldown entries are created and decremented correctly, stat multipliers match Player.stats, and is_ready() correctly reflects cooldown state for each slot\n</info added on 2025-12-16T21:57:28.721Z>",
            "status": "done",
            "testStrategy": "Verify slots can be assigned null/weakref weapons, cooldowns decrement in _process, and multipliers scale base rates correctly via debug prints.",
            "updatedAt": "2025-12-16T21:57:34.629Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement weapon manager component logic",
            "description": "Build update loop to manage cooldowns and trigger auto-attacks independently per slot.",
            "dependencies": [
              1
            ],
            "details": "In WeaponManager._process, iterate slots, decrement cooldowns delta-multiplied by attack speed, and call attack() on ready weapons targeting nearest enemy or forward direction. Expose equip(slot_id, weapon) and get_cooldown(slot_id) for future use.\n<info added on 2025-12-17T20:15:52.874Z>\nImplementation complete:\n\n- equip(slot_index, weapon) assigns the weapon to the internal slots array, clamps/validates slot_index to 0–5, and resets the corresponding slot cooldown to 0 so the weapon is immediately eligible to fire on the next ready check.\n- get_cooldown(slot_index) returns the current cooldown value for the given slot, with the same 0–5 index validation used by equip.\n- _process(delta) now runs the auto-attack loop each frame, iterating all 6 slots, skipping null entries, decrementing each active cooldown by delta * attack_speed_multiplier pulled from the owning player’s stats component, and clamping at 0.\n- When a slot’s cooldown reaches 0, the manager:\n  - Logs a debug message including the slot index, current cooldown, and computed attack_speed_multiplier.\n  - Confirms readiness via is_ready(slot_index) before firing.\n  - Emits weapon_attack_started with the slot index and weapon reference.\n  - Calls weapon.attack() safely only if the weapon implements that method.\n  - Emits weapon_attack_completed after the attack call.\n- Auto-attacks are fully independent per slot; no input actions or player controller state are consulted in WeaponManager._process, so multiple equipped weapons can fire on their own schedules.\n- Weapons are required to call set_cooldown(new_value) on the manager (or their assigned slot) after attacking; WeaponManager does not impose cooldown durations itself, only decrements and readiness checks.\n- Signal wiring (weapon_attack_started / weapon_attack_completed) is in place for later integration with passives or VFX, and current logging confirms the emission order around each attack.\n- Basic tests confirm:\n  - Cooldowns decrement correctly at different attack_speed_multiplier values from the player stats.\n  - Debug prints show per-slot readiness and cooldown values over time.\n  - equip() and get_cooldown() correctly handle valid indices (0–5) and guard against out-of-range values.\n- Subtask is ready for Task 8.3 to introduce a shared weapon base class that will standardize attack() and cooldown behavior across all weapon types.\n</info added on 2025-12-17T20:15:52.874Z>",
            "status": "done",
            "testStrategy": "Log attack triggers and cooldown states; confirm no overlaps and correct firing rates independent of player input.",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T20:16:00.108Z"
          },
          {
            "id": 3,
            "title": "Define minimal extensible weapon base class",
            "description": "Create IWeapon interface or base script for concrete weapons with auto-attack hooks.",
            "dependencies": [
              1
            ],
            "details": "Script with abstract attack(), get_base_cooldown(), get_base_damage() methods, plus virtual on_equip/passive_modifier hooks. Design for polymorphism so future weapons override behavior while sharing manager logic; integrate player stats via passed references.\n<info added on 2025-12-18T14:11:46.079Z>\nImplemented BaseWeapon script at res://scripts/weapons/base_weapon.gd with abstract attack(), get_base_cooldown(), and get_base_damage() methods, virtual on_equip(), on_unequip(), and apply_passive_modifier() hooks, plus helper methods get_final_damage(), get_final_cooldown(), and reset_cooldown(), and member references weapon_manager: WeaponManager, player: CharacterBody2D, and slot_index: int. Updated res://scripts/weapons/weapon_manager.gd equip() to accept a typed BaseWeapon, assign weapon_manager, player, and slot_index on the weapon, and invoke weapon.on_equip(), ensuring the manager’s _process() auto-attack loop calls weapon.attack() while preventing direct use of the abstract base via an assert on the unoverridden attack().\n</info added on 2025-12-18T14:11:46.079Z>",
            "status": "done",
            "testStrategy": "Instantiate base class, mock attack() to print stats, confirm it integrates with manager without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-12-18T14:11:56.044Z"
          },
          {
            "id": 4,
            "title": "Integrate with pooling and spatial systems",
            "description": "Hook weapon attacks to spawn pooled projectiles or effects via spatial queries.",
            "dependencies": [
              2,
              3
            ],
            "details": "In weapon attack(), query nearest enemy via SpaceState2D (from Tasks 6/7), spawn pooled projectile from global pooler with direction/position from player, apply damage/scaling. Use signals for VFX/SFX; keep generic for non-projectile weapons later.",
            "status": "done",
            "testStrategy": "Spawn debug projectiles, verify pooling reuse, spatial targeting picks correct enemy, and effects trigger.",
            "parentId": "undefined",
            "updatedAt": "2025-12-18T16:24:35.515Z"
          },
          {
            "id": 5,
            "title": "Build test weapon and diagnostic scene",
            "description": "Implement simple test weapon and scene to validate auto-firing and stat scaling.",
            "dependencies": [
              4
            ],
            "details": "Create TestWeapon extending base with 2s cooldown, 10 damage projectile spawn. Build scene with player, dummy enemies, stat UI; equip to slot 0. Ensure design uses slots/signals for easy swap to 6 future weapons and passive stat tests.",
            "status": "done",
            "testStrategy": "Run scene: confirm auto-fire every ~2s (modulated by attack speed), damage scales with player stats, cooldown UI updates, no input required.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T12:59:00.135Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Decompose into subtasks that (1) design or align the weapon management interface on the player (slots, cooldown tracking, stat modifiers), (2) implement a weapon manager or component that updates cooldowns and triggers attacks, (3) define a minimal weapon interface or base class that concrete weapons can implement, (4) integrate with pooling and spatial systems for spawning projectiles or effects, and (5) build a simple test weapon plus diagnostic scene to validate automatic firing and stat scaling. For each subtask, specify how to keep the design extensible for future weapons and passives.",
        "updatedAt": "2025-12-19T12:59:00.135Z"
      },
      {
        "id": "9",
        "title": "Implement basic progression loop scaffolding",
        "description": "Lay down the core systems for XP collection, leveling, and stat upgrades without full content.",
        "details": "Create a pickup type representing XP gems that the player collects within a Pickup Range of 50 pixels, ideally reusing the pooling system for pickups.[1] Implement a simple XP curve, level tracking, and a placeholder level-up UI that can present upgrade choices for weapons and passives later, aligning with any existing UI and progression frameworks already in the codebase.[2]",
        "testStrategy": "Spawn XP pickups in a test scene, collect them, and verify that player XP and level increase correctly, that a level-up screen appears at thresholds, and that choosing an option successfully applies a stat change or logs a placeholder effect.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define XP pickup scene and pooling integration",
            "description": "Create XP gem pickup scene with sprite, collision, and value property, integrating with existing pooling system for efficient spawning.",
            "dependencies": [],
            "details": "Design XP pickup as a pooled Area2D or RigidBody2D scene with XP value export var (e.g., 10-50 XP). Add to existing PickupPool manager, spawn via get_pooled('xp_gem', position). Set Pickup Range detection to 50px matching player stats from Task 4.",
            "status": "done",
            "testStrategy": "Spawn 10 XP pickups manually in editor, verify pooling reuse and no memory leaks on collect/despawn cycles.",
            "updatedAt": "2025-12-19T18:06:53.114Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement XP and level data model with XP curve",
            "description": "Create Progression resource or singleton with XP tracking, level calculation, and configurable XP curve for leveling thresholds.",
            "dependencies": [],
            "details": "Define XPToNextLevel curve using quadratic formula (e.g., level * 100 + level^2 * 20). Track current_xp, current_level, xp_at_level_up as exported vars. Add methods: add_xp(amount), check_level_up(), get_progress_ratio(). Align with existing stats patterns from Task 4.",
            "status": "done",
            "testStrategy": "Unit test XP curve: verify level 1→2 at 100XP, level 2→3 at 240XP total, precise calculations match formula.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T20:13:41.966Z"
          },
          {
            "id": 3,
            "title": "Wire XP collection into player and progression",
            "description": "Connect player detection to XP pickups: on overlap within 50px pickup range, grant XP and despawn pickup.",
            "dependencies": [
              1,
              2
            ],
            "details": "In player controller (Task 4), add Area2D monitor with 50px radius. On body_entered, check if XP pickup type, call progression.add_xp(pickup.xp_value), queue pickup despawn/recycle. Integrate with pooling deactivate. Use existing input_vector patterns.",
            "status": "done",
            "testStrategy": "Move player near XP gem, verify XP increases by correct amount and gem despawns immediately.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T21:16:43.663Z"
          },
          {
            "id": 4,
            "title": "Create placeholder level-up UI and flow",
            "description": "Build level-up screen that pauses game, displays upgrade choices, handles selection, and applies effects.",
            "dependencies": [
              2
            ],
            "details": "Extend existing UI framework (from pause menu patterns). Create LevelUpPanel with CanvasLayer/Modal, pause get_tree().paused=true on level_up signal. Show 3 upgrade buttons with icons/text. Use ui_accept/cancel actions from Task 3. Unpause after selection.",
            "status": "done",
            "testStrategy": "Trigger level-up signal manually, verify game pauses, UI appears center-screen, navigation works with keyboard/controller.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T20:05:34.201Z"
          },
          {
            "id": 5,
            "title": "Integrate stat-upgrade options with effects",
            "description": "Add placeholder upgrades that modify player stats or log debug output, selectable in level-up UI.",
            "dependencies": [
              3,
              4
            ],
            "details": "Define 3 options: '+20% Move Speed', '+10 Max HP', 'Weapon Damage +1'. On select, apply to player stats resource (reuse Task 4 patterns), print debug 'Applied [upgrade] at level X'. Emit signal for future weapon/passive integration. Close UI and resume game.",
            "status": "done",
            "testStrategy": "Level up, select each option 2x, verify stats update (speed=240→288, etc.) and console logs correct applications.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:04:29.587Z"
          },
          {
            "id": 6,
            "title": "Build test scenarios for end-to-end leveling",
            "description": "Create comprehensive test scene validating XP collection, leveling, UI flow, and upgrade application.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "New TestProgression scene: spawn player, 20 XP gems in grid. Auto-collect path or manual. Assert XP thresholds trigger level-ups, UI sequence completes, stats persist post-upgrade. Log full flow, FPS stable. Align with Task 4 test patterns.",
            "status": "done",
            "testStrategy": "Run test scene, collect all XP to reach level 3+, verify 2 level-ups occur, all 6 upgrades selectable, stats match expected values, no crashes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T00:15:23.888Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Split into subtasks for (1) defining the XP pickup scene and pooling integration, (2) implementing the XP and level data model, including a configurable XP curve, (3) wiring XP collection into the player and progression components, (4) creating the placeholder level-up UI and flow (pause game, selection, apply effect), (5) integrating simple stat-upgrade or placeholder options that affect player stats or log debug output, and (6) building test scenarios to validate end-to-end leveling behavior. For each subtask, align data flow and UI patterns with existing progression and interface systems in the project.",
        "updatedAt": "2025-12-21T00:15:23.888Z"
      },
      {
        "id": "10",
        "title": "Performance validation for Week 3 target",
        "description": "Verify that the foundation meets the Week 3 performance and stability goals.",
        "details": "Create a dedicated performance test scene or mode that can spawn at least 100 active enemies using the pooling and spatial partitioning systems while the player moves and auto-attacks.[3] Measure FPS and frame time using Godot’s profiler to confirm stable 60 FPS under this load, and document any bottlenecks or further optimizations needed to reach the eventual 200+ enemy target.[1]",
        "testStrategy": "Run the performance scene on representative hardware, record FPS and profiler metrics, and ensure there are no major spikes in physics or script time. Adjust enemy update frequency or partitioning parameters if needed to maintain targets.",
        "priority": "high",
        "dependencies": [
          "4",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define performance test scene setup",
            "description": "Design and create a dedicated test scene specifying enemy compositions (100+ pooled enemies), player setup with Sarimanok visuals and movement, and weapon auto-attack behavior.",
            "dependencies": [],
            "details": "Use 640x360 viewport from Task 2; spawn enemies via pooling (Task 6) and spatial grid (Task 7); player auto-moves/attacks continuously. Target hardware: mid-range PC (e.g., GTX 1060, i5); pass if scene loads without errors and sustains load.",
            "status": "done",
            "testStrategy": "Verify scene runs 100 enemies with player active; fail if <100 enemies or crashes.",
            "updatedAt": "2025-12-22T05:04:02.086Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement automated load generation scripts",
            "description": "Script enemy spawning, activation, player movement, and auto-attacks using existing pooling and spatial partitioning systems for sustained high load.",
            "dependencies": [
              1
            ],
            "details": "Leverage Task 6 pooling (300 enemies) and Task 7 grid for 100 active enemies; automate player patrol/auto-attack loops. Target hardware: mid-range PC; pass if maintains 100 active enemies indefinitely without new instantiations.",
            "status": "done",
            "testStrategy": "Monitor node creation in debugger; fail if queue_free/instantiate called or <100 active.",
            "parentId": "undefined",
            "updatedAt": "2025-12-22T20:40:58.736Z"
          },
          {
            "id": 3,
            "title": "Configure Godot profiler and metrics capture",
            "description": "Set up profiling procedures to measure FPS, frame time, script/physics costs using Godot’s built-in profiler and Performance class monitors.",
            "dependencies": [
              1,
              2
            ],
            "details": "Enable Profiler/Monitors tabs; track Performance.get_monitor(Performance.TIME_FPS), TIME_PROCESS, PHYSICS_2D_ACTIVE_OBJECTS; log to file/console. Target: 60 FPS avg, <16.67ms frame time; pass if stable under load on target hardware.",
            "status": "done",
            "testStrategy": "Run 60s test; fail if avg FPS <60 or frame time >20ms sustained.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T19:33:38.637Z"
          },
          {
            "id": 4,
            "title": "Run tests, document bottlenecks, and triage optimizations",
            "description": "Execute performance tests, analyze profiler data, document bottlenecks, and propose optimization subtasks for 200+ enemy goal.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Test on mid-range PC; triage script/physics/render spikes; propose fixes like update frequency tweaks. Pass: 60 FPS with 100 enemies; document gaps to 200+ target.",
            "status": "done",
            "testStrategy": "Compare before/after metrics; fail if major spikes (>50ms) in physics/script.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T21:07:47.802Z"
          },
          {
            "id": 5,
            "title": "Develop repeatable benchmark checklist/script",
            "description": "Create a documented checklist or automation script for rerunning the performance benchmark in future iterations with consistent metrics.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Script includes: load scene, start profiler, run 60s at 100 enemies, export CSV/logs, verify thresholds (60 FPS). Include hardware specs and pass/fail: stable 60 FPS, no >20ms spikes.",
            "status": "done",
            "testStrategy": "Rerun benchmark twice; fail if results vary >5% FPS or setup takes >2min.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T16:45:51.431Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Organize into subtasks that (1) define the performance test scene or mode (enemy compositions, player setup, weapon behavior), (2) script automated or semi-automated load generation for enemies and attacks using existing pooling and spatial systems, (3) set up profiling procedures and metrics capture (FPS, frame time, script/physics cost), (4) document and triage any bottlenecks with proposed optimization tasks, and (5) create a repeatable checklist or script for rerunning the benchmark in future iterations. For each subtask, clarify target hardware assumptions and pass/fail thresholds tied to design goals.",
        "updatedAt": "2025-12-24T16:45:51.431Z"
      },
      {
        "id": "11",
        "title": "Create Enemy Base Scene with Area2D and Movement Logic",
        "description": "Implement the base Duwende enemy scene using Area2D with placeholder ColorRect art, basic movement toward player, and damage on contact, aligned with the current Godot 4 project structure and player/damage systems.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Codebase alignment:\n- Place the enemy scene under `res://scenes/enemies/duwende/enemy_duwende.tscn` to stay consistent with existing enemy and spawn setups.\n- Implement the script as `res://scripts/enemies/enemy_duwende.gd`, extending `Area2D` and following existing naming/export patterns used in other enemy or actor scripts.\n- Integrate with the Classic Sarimanok player from Task 4 by assuming a `CharacterBody2D` player in group `\"player\"` with a `take_damage(amount: int)` method and HP/invincibility handled in the player/health component.\n\nScene requirements (Godot 4):\n- Root: `Area2D` named `EnemyDuwende`.\n- Children:\n  - `CollisionShape2D` using a `CircleShape2D` with radius = 16 (32×32 logical footprint) on the enemy-damage collision layer/mask already used for other enemies.\n  - `ColorRect` (placeholder art) with size 32×32, modulate color green, positioned so it visually matches the collision.\n- Add the root node to an `\"enemy\"` group to integrate with spatial partitioning and spawn systems.\n\nScript requirements (`enemy_duwende.gd`):\n- Exported stats to sync with scaling systems and Task 15:\n  - `@export var base_speed: float = 80.0`\n  - `@export var base_max_hp: int = 10`\n  - `@export var base_damage: int = 5`\n- Runtime fields:\n  - `var speed: float = base_speed`\n  - `var hp: int = base_max_hp`\n- Player reference acquisition in `_ready()` using existing group patterns:\n  ```gdscript\n  @onready var player: Node2D = get_tree().get_first_node_in_group(\"player\")\n  ```\n- Movement in `_physics_process(delta)` using direct position update (simple base enemy, no CharacterBody2D):\n  ```gdscript\n  func _physics_process(delta: float) -> void:\n      if player == null:\n          return\n      var direction: Vector2 = (player.global_position - global_position).normalized()\n      global_position += direction * speed * delta\n  ```\n- Damage/collision via `area_entered` or `body_entered` depending on current project pattern; base implementation using `area_entered` to match the original spec and player damage Area2D:\n  ```gdscript\n  @export var damage: int = 5\n  @export var hp: int = 10\n\n  func _ready() -> void:\n      add_to_group(\"enemy\")\n      area_entered.connect(_on_area_entered)\n\n  func _on_area_entered(area: Area2D) -> void:\n      if area.is_in_group(\"player\") and area.has_method(\"take_damage\"):\n          area.take_damage(damage)\n          queue_free()\n  ```\n- Ensure the enemy registers/unregisters with the grid-based spatial partitioning system from Task 7 if that system expects an API such as `spatial_grid.register_enemy(self)` and `spatial_grid.unregister_enemy(self)`.\n\nComplexity/architecture notes:\n- This enemy serves as the **baseline implementation** whose stats and scene structure will be duplicated and adjusted for the Red Duwende variant in Task 15, and whose instances will be spawned via the ring-based SpawnManager in Task 13.\n- Keep the script small and focused (movement + simple contact damage) so more complex behaviors can be layered via composition or inherited scripts later.\n",
        "testStrategy": "- Create a temporary test scene (e.g., `res://scenes/test/test_enemy_duwende.tscn`) that instantiates the existing player (Task 4) and one `EnemyDuwende` placed ~200 px away.\n- Run the scene and, using the Godot remote inspector, verify that the distance between enemy and player decreases at approximately 80 px/s over 1 second.\n- Enable Debug > Visible Collision Shapes and confirm the enemy `CollisionShape2D` overlaps the player's damage-receiving Area2D/CollisionObject2D when they visually touch.\n- On overlap, confirm that the player's HP (from the player health component) decreases by 5 and the enemy instance calls `queue_free()` (disappears), without breaking the player's existing invincibility logic.\n- Add 50 instances of `EnemyDuwende` via a temporary script or scene to verify that FPS remains stable and that the spatial partitioning system (Task 7) continues to function correctly if the enemy is registered with it.\n- Optionally spawn enemies just outside the viewport using the ring-based SpawnManager prototype (Task 13) to ensure the scene and script are compatible with the spawn pipeline and scaling systems.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up enemy_duwende.tscn with Area2D nodes",
            "description": "Create the enemy scene file with Area2D root, add CollisionShape2D with 32x32 CircleShape2D, and ColorRect with green color for placeholder art.",
            "dependencies": [],
            "details": "In Godot, create `res://scenes/enemies/duwende/enemy_duwende.tscn` with an `Area2D` root named `EnemyDuwende`.\n- Add a `CollisionShape2D` child, assign a `CircleShape2D` with radius = 16, and set its collision layer/mask to match the existing enemy-damage configuration used by the player from Task 4.\n- Add a `ColorRect` child as placeholder art, set size to 32×32 and color to green, and align it visually with the collision shape.\n- Add the root node to the `\"enemy\"` group so it can participate in spatial partitioning and pooling later.",
            "status": "done",
            "testStrategy": "Open `enemy_duwende.tscn` and verify the node tree is `EnemyDuwende (Area2D)` > `CollisionShape2D` + `ColorRect`.\nEnable Debug > Visible Collision Shapes and confirm the circular collision area matches the visible 32×32 green square in size and position.\nCheck that the root node is in the `\"enemy\"` group and that its collision layer/mask allows interaction with the existing player damage Area2D/CollisionObject2D.",
            "updatedAt": "2025-12-24T23:39:55.293Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement basic movement logic in script",
            "description": "Attach GDScript to Area2D root and code _physics_process for movement toward player at speed=80, consistent with current player and enemy architecture.",
            "dependencies": [
              1
            ],
            "details": "Create `res://scripts/enemies/enemy_duwende.gd` and attach it to the `EnemyDuwende` Area2D root.\n- Use Godot 4 syntax:\n  ```gdscript\n  extends Area2D\n\n  @export var base_speed: float = 80.0\n  var speed: float = base_speed\n  @onready var player: Node2D = get_tree().get_first_node_in_group(\"player\")\n\n  func _physics_process(delta: float) -> void:\n      if player == null:\n          return\n      var direction: Vector2 = (player.global_position - global_position).normalized()\n      global_position += direction * speed * delta\n  ```\n- Ensure this pattern matches how other moving actors/enemies in the project reference the player (via the `\"player\"` group).",
            "status": "done",
            "testStrategy": "In a test scene with the existing player and one `EnemyDuwende` 200 px away, run the game and sample positions over 1 second.\nConfirm that the distance between enemy and player decreases by roughly 80 px (± small integration error) per second and movement appears smooth with no jitter.\nTemporarily log `direction` and `global_position` each frame to verify normalization and correct movement direction.",
            "parentId": "undefined",
            "updatedAt": "2025-12-25T17:32:14.031Z"
          },
          {
            "id": 3,
            "title": "Add collision detection and damage logic",
            "description": "Implement area_entered signal (or equivalent) to detect the player’s damage receiver, apply damage=5, and queue_free enemy. Add HP=10 base stat fields for compatibility with scaling systems.",
            "dependencies": [
              1,
              2
            ],
            "details": "In `enemy_duwende.gd`, add exported stats and connect to the Area2D overlap signal used in the project:\n```gdscript\n@export var base_damage: int = 5\n@export var base_max_hp: int = 10\nvar damage: int = base_damage\nvar hp: int = base_max_hp\n\nfunc _ready() -> void:\n    add_to_group(\"enemy\")\n    area_entered.connect(_on_area_entered)\n\nfunc _on_area_entered(area: Area2D) -> void:\n    if area.is_in_group(\"player\") and area.has_method(\"take_damage\"):\n        area.take_damage(damage)\n        queue_free()\n```\nIf the current codebase instead uses `body_entered` for player/enemy contact, mirror that pattern by connecting `body_entered` and adjusting the callback signature to use `body` instead of `area`.\nEnsure `hp` and `damage` fields can later be overridden or scaled by the SpawnManager and the Red Duwende variant from Task 15.",
            "status": "done",
            "testStrategy": "With the existing player scene from Task 4, place `EnemyDuwende` so that the player can walk into it.\nRun the scene, move the player into the enemy, and verify that the player’s HP value decreases by exactly 5 while respecting any existing invincibility window logic.\nConfirm that the enemy instance calls `queue_free()` when it damages the player and that no errors are logged if multiple enemies collide with the player in quick succession.\nStress test by manually instancing ~50 `EnemyDuwende` in the scene and verifying that contact damage still works reliably without dropping FPS or producing physics/overlap warnings.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T14:32:41.057Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Scene setup with Area2D, CollisionShape2D, and ColorRect; 2) Basic movement logic in _physics_process toward player; 3) area_entered collision detection and damage application with cleanup.",
        "updatedAt": "2025-12-26T14:32:41.057Z"
      },
      {
        "id": "12",
        "title": "Implement Enemy Stat Scaling Functions",
        "description": "Add time-based scaling for HP and damage using provided formulas in spawn manager.",
        "details": "In spawn manager script, implement:\nfunc get_scaled_hp(base_hp: int, elapsed_minutes: float) -> int:\n    var scale = 1.0 + (elapsed_minutes / 5.0) * 0.05\n    return int(base_hp * scale)\nfunc get_scaled_damage(base_damage: int, elapsed_minutes: float) -> int:\n    var scale = 1.0 + (elapsed_minutes / 5.0) * 0.03\n    return int(base_damage * scale)\nTrack get_tree().edited_scene_root.get_node('GameTimer').elapsed_minutes or similar global time.",
        "testStrategy": "Test at 0min: Green HP=10,dmg=5; 10min: HP=11,dmg=5; 20min: HP=12,dmg=6. Verify Red at 10min: HP=27,dmg=10 using debug prints.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Scaling Function Definitions",
            "description": "Implement the get_scaled_hp and get_scaled_damage functions in the spawn manager script using the exact formulas provided.",
            "dependencies": [],
            "details": "Copy the provided function code directly into SpawnManager.gd: calculate scale as 1.0 + (elapsed_minutes / 5.0) * 0.05 for HP and * 0.03 for damage, then return int(base * scale).",
            "status": "done",
            "testStrategy": "Call functions with test values: get_scaled_hp(10, 0) == 10, get_scaled_damage(5, 0) == 5 using debug prints.",
            "updatedAt": "2025-12-27T17:35:33.866Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Access Global Game Timer",
            "description": "Create a reference to the GameTimer node's elapsed_minutes in the spawn manager for use in scaling functions.",
            "dependencies": [
              1
            ],
            "details": "Add onready var game_timer = get_tree().edited_scene_root.get_node('GameTimer'); Implement a helper func get_elapsed_minutes() -> float: return game_timer.elapsed_minutes.",
            "status": "done",
            "testStrategy": "Print get_elapsed_minutes() at spawn time and verify it matches GameTimer display value.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T17:04:28.530Z"
          },
          {
            "id": 3,
            "title": "Integrate Scaling into Enemy Spawning",
            "description": "Modify enemy spawn logic to use scaled HP and damage values instead of base values when creating new enemies.",
            "dependencies": [
              1,
              2
            ],
            "details": "In spawn_enemy(type) function, replace base_hp assignments with get_scaled_hp(base_hp, get_elapsed_minutes()), same for damage. Update both Green and Red enemy types.",
            "status": "done",
            "testStrategy": "Spawn Green at 0min (HP=10,dmg=5), 10min (HP=11,dmg=5), 20min (HP=12,dmg=6); verify via enemy inspector or prints.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T18:25:22.017Z"
          },
          {
            "id": 4,
            "title": "Update Enemy HP Storage",
            "description": "Ensure spawned enemies store their scaled HP value correctly for damage calculations and death checks.",
            "dependencies": [
              3
            ],
            "details": "In enemy script, set self.current_hp = scaled_hp from spawn manager when instantiated. Verify damage system uses current_hp.",
            "status": "done",
            "testStrategy": "Spawn Red at 10min, confirm current_hp=27 in enemy script, take damage and verify death at correct threshold.",
            "parentId": "undefined",
            "updatedAt": "2025-12-29T15:06:52.014Z"
          },
          {
            "id": 5,
            "title": "Comprehensive Scaling Tests",
            "description": "Run full test suite verifying scaling works across time intervals for both enemy types with debug validation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Test sequence: Play to 0/10/20min, spawn Green/Red, check HP/dmg values match formula (Green10min:HP11,dmg5; Red10min:HP27,dmg10), monitor FPS stability.",
            "status": "done",
            "testStrategy": "Use debug prints or overlay to display live scaled values; kill 10 enemies per interval to confirm drops unaffected by scaling.",
            "parentId": "undefined",
            "updatedAt": "2025-12-30T19:09:15.414Z"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-12-30T19:09:15.414Z"
      },
      {
        "id": "13",
        "title": "Build Ring-Based Spawn System with Polar Coordinates",
        "description": "Create spawn manager that spawns enemies in ring around player (400-500px distance) using polar coordinates.",
        "details": "In SpawnManager node/script: Calculate spawn_dist = 465.0 (viewport_diagonal/2 + 100). Random angle = randf() * TAU. Spawn pos = player.global_position + Vector2(cos(angle), sin(angle)) * spawn_dist. Clamp to map bounds: max(0, min(1920, x)), max(0, min(1088, y)). Use get_scaled_hp/damage. Add spawn timer.",
        "testStrategy": "Verify all spawns occur outside viewport (distance >400px from player), within map bounds, uniform angle distribution (plot 100 spawns), correct enemy type/stats based on time.",
        "priority": "high",
        "dependencies": [
          "11",
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "SpawnManager Node and Script Setup",
            "description": "Create and configure the SpawnManager node with necessary references to player, enemy scenes, and initial script structure.",
            "dependencies": [],
            "details": "Add SpawnManager as Node2D or Control under main scene. Attach script spawn_manager.gd. Export player NodePath, enemy prefab PackedScene. Initialize variables for spawn_dist, map bounds (1920x1088). Ensure dependencies Tasks 11-12 resolved.",
            "status": "done",
            "testStrategy": "Verify node exists in scene tree, script attached, player/enemy references valid via remote inspector.",
            "updatedAt": "2025-12-31T17:26:48.363Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Polar Coordinate Position Calculation",
            "description": "Calculate spawn positions using ring-based polar coordinates around player at 400-500px distance.",
            "dependencies": [
              1
            ],
            "details": "Compute viewport_diagonal = sqrt(1920² + 1088²). Set spawn_dist = viewport_diagonal/2 + 100 (~465px). Generate angle = randf() * TAU. Compute pos = player.global_position + Vector2(cos(angle), sin(angle)) * spawn_dist * randf_range(0.8, 1.0) for 400-500px ring.",
            "status": "done",
            "testStrategy": "Spawn 100 positions, verify all distances from player 400-500px using debug draw or console logs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-01T16:02:36.778Z"
          },
          {
            "id": 3,
            "title": "Add Map Bounds Clamping Logic",
            "description": "Clamp calculated spawn positions to valid map boundaries to prevent off-screen spawning.",
            "dependencies": [
              1,
              2
            ],
            "details": "After polar calculation, apply: clamped_x = max(0, min(1920, pos.x)), clamped_y = max(0, min(1088, pos.y)). Use clamped position for instantiation. Log unclamped vs clamped positions for debugging boundary cases.",
            "status": "done",
            "testStrategy": "Test edge cases: player at corners/center, verify 100% spawns within 0-1920x, 0-1088y bounds.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T16:05:12.949Z"
          },
          {
            "id": 4,
            "title": "Integrate Spawn Timer with Stat Scaling",
            "description": "Add timed spawning with get_scaled_hp/damage calls and connect to spawn logic.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create Timer node child of SpawnManager, set wait_time=2.0s, aut-start=true. Connect timeout signal to spawn_enemy() function. In spawn_enemy(): instantiate enemy at clamped pos, call enemy.get_scaled_hp(), enemy.get_scaled_damage() based on game time/progress.",
            "status": "done",
            "testStrategy": "Run for 30s, verify spawn rate ~every 2s, enemy stats scale correctly per game time, no crashes on repeated spawning.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:16:28.895Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into: 1) SpawnManager node/script setup; 2) Polar coordinate position calculation; 3) Map bounds clamping; 4) Spawn timer integration with stat scaling.",
        "updatedAt": "2026-01-02T17:16:28.895Z"
      },
      {
        "id": "14",
        "title": "Implement Dynamic Spawn Rate Scaling and Timeline Logic",
        "description": "Add exponential spawn interval scaling (2s → 0.8s) and enemy type unlock at 8:00.",
        "details": "In SpawnManager: base_interval=2.0, difficulty_scale=1.05. func get_spawn_interval(elapsed_minutes: float) -> float: return base_interval / pow(difficulty_scale, elapsed_minutes). Timer.wait_time = get_spawn_interval(elapsed_minutes). If elapsed_minutes < 8: spawn Green only; else: 70% Green/30% Red weighted random. Verify: 0min=2s, 5min≈1.57s, 10min≈1.23s.",
        "testStrategy": "Simulate time progression, measure actual spawn intervals match formula (±0.01s), confirm Red spawns only after 8min, correct spawn ratios post-8min (100 spawns: ~70 Green/~30 Red).",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Exponential Spawn Interval Formula",
            "description": "Add get_spawn_interval function in SpawnManager using base_interval=2.0 and difficulty_scale=1.05 with formula base_interval / pow(difficulty_scale, elapsed_minutes).",
            "dependencies": [],
            "details": "Define class variables base_interval: float = 2.0 and difficulty_scale: float = 1.05. Implement func get_spawn_interval(elapsed_minutes: float) -> float: return base_interval / pow(difficulty_scale, elapsed_minutes). Access elapsed_minutes from GameTimer node.",
            "status": "done",
            "testStrategy": "Verify at 0min returns 2.0s, 5min ≈1.57s, 10min ≈1.23s using debug prints or unit tests.",
            "updatedAt": "2026-01-02T23:14:10.404Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Dynamic Timer Wait Time Updates",
            "description": "Update SpawnManager Timer.wait_time dynamically by calling get_spawn_interval on each timeout or process delta.",
            "dependencies": [
              1
            ],
            "details": "In _on_timer_timeout() or _process(delta): get current elapsed_minutes from GameTimer, set Timer.wait_time = get_spawn_interval(elapsed_minutes), then Timer.start(). Ensure smooth scaling without pauses.",
            "status": "done",
            "testStrategy": "Simulate time progression, log Timer.wait_time at intervals, confirm matches formula within ±0.01s.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T17:02:07.038Z"
          },
          {
            "id": 3,
            "title": "Implement Enemy Type Unlock and Weighted Selection",
            "description": "Add time-based enemy type logic: Green only before 8min, then 70% Green / 30% Red weighted random selection.",
            "dependencies": [
              1
            ],
            "details": "In spawn function: if elapsed_minutes < 8: spawn Green; else: weighted_random([Green, 70], [Red, 30]) using randf() or RandomNumberGenerator. Integrate with existing pool system.",
            "status": "done",
            "testStrategy": "Run 100 spawns pre/post 8min, verify 100% Green before, ~70/30 ratio after (within ±5%).",
            "parentId": "undefined",
            "updatedAt": "2026-01-04T18:18:50.414Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Exponential interval formula implementation; 2) Dynamic Timer.wait_time updates; 3) Enemy type probability logic with time-based unlocks.",
        "updatedAt": "2026-01-04T18:18:50.414Z"
      },
      {
        "id": "15",
        "title": "Add Red Duwende Variant and Object Pooling System",
        "description": "Create Red Duwende (speed=100, HP=25, damage=10) and implement object pooling for performance.",
        "details": "Duplicate enemy scene to 'enemy_duwende_red.tscn', change ColorRect to red, update base stats. Pool: Pre-instantiate 50 Green + 30 Red in SpawnManager, disable initially. On spawn: enable pooled instance, reset pos/HP/stats. On death: reset stats, disable/move offscreen, return to pool. No new instancing after pool exhaustion.",
        "testStrategy": "Verify Red stats/behavior correct, pool doesn't create >80 total enemies, memory stable with continuous spawning/dying, FPS maintained at 200+ enemies.",
        "priority": "medium",
        "dependencies": [
          "11",
          "13",
          "14"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Duplicate and Modify Red Duwende Scene",
            "description": "Duplicate the existing Green Duwende enemy scene to create 'enemy_duwende_red.tscn', change ColorRect color to red, and update base stats to speed=100, HP=25, damage=10 following Godot 4.5 scene duplication best practices.",
            "dependencies": [],
            "details": "Right-click enemy_duwende_green.tscn in FileSystem dock, select 'Duplicate', rename to 'enemy_duwende_red.tscn'. Open scene, select ColorRect node, set color to red (e.g., Color(1,0.2,0.2)). Add script properties or export vars for speed=100, max_hp=25, damage=10. Save and verify scene loads without errors.",
            "status": "done",
            "testStrategy": "Load both scenes in editor, confirm Red has correct color and stats differ from Green. Run scene standalone to verify basic functionality intact.",
            "updatedAt": "2026-01-07T02:06:57.810Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Initialize Object Pools in SpawnManager",
            "description": "Extend SpawnManager to pre-instantiate pools: 50 Green Duwende + 30 Red Duwende instances at _ready(), store in separate arrays, set all inactive and positioned offscreen.",
            "dependencies": [
              1
            ],
            "details": "In SpawnManager script, create Array green_pool: Array[Node2D] = [], red_pool: Array[Node2D] = []. In _ready(): for i in 50: var enemy = enemy_duwende_green.instantiate(); green_pool.append(enemy); add_child(enemy); enemy.visible=false; enemy.position = Vector2(-1000,-1000). Repeat for 30 Red. Leverage Task 6 pooling infrastructure if available.",
            "status": "done",
            "testStrategy": "Print pool sizes in _ready(), confirm 50 Green + 30 Red total 80 enemies as children of SpawnManager, all disabled/offscreen initially.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T02:09:08.307Z"
          },
          {
            "id": 3,
            "title": "Implement Spawn Logic from Pools",
            "description": "Modify spawn function to select from appropriate pool (Green or Red per Task 14 logic), activate pooled instance, reset position/stats/HP, reparent to game world.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update spawn_enemy(type: String) func: if type=='green' and green_pool.size()>0: var enemy=green_pool.pop_front(); else return null. enemy.reset_state(); enemy.position=spawn_pos; enemy.visible=true; enemy.get_parent().remove_child(enemy); get_tree().current_scene.add_child(enemy); return enemy. Integrate with Task 14 weighted spawn after 8min.",
            "status": "done",
            "testStrategy": "Trigger 10 spawns each type, verify enemies activate from pool (no new instantiates), correct positions/stats, pool sizes decrease.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T02:09:44.064Z"
          },
          {
            "id": 4,
            "title": "Implement Death, Reset, and Return to Pool",
            "description": "Add reset_state() method to enemy scripts and death signal handler to disable enemy, reset all stats/position, return to correct pool in SpawnManager.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In enemy script: func reset_state(): hp=max_hp; speed=base_speed; position=Vector2.ZERO; velocity=Vector2.ZERO; visible=false; get_parent().remove_child(self). In SpawnManager death_connected signal: if enemy.is_in_group('green'): green_pool.push_front(enemy); add_child(enemy); enemy.position=Vector2(-1000,-1000). Same for red.",
            "status": "done",
            "testStrategy": "Spawn enemies, kill them via damage, confirm they return to pool (sizes increase), stats reset, no queue_free calls, memory stable.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T02:10:23.256Z"
          },
          {
            "id": 5,
            "title": "Handle Pool Exhaustion and Performance Verification",
            "description": "Implement pool exhaustion check (return null/skip spawn if empty), verify no new instantiation post-init, test FPS/memory with 200+ enemies per Godot 4.5 bullet heaven best practices.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "In spawn func: if pool.empty(): print_warning('Pool exhausted for '+type); return null. Monitor Profiler: confirm 0 instantiate calls during gameplay, FPS stable at 200+ enemies, memory < peak after waves. Stress test: spawn waves until exhaustion, verify graceful degradation.",
            "status": "done",
            "testStrategy": "Exhaust pools by spawning max, confirm no crashes/new nodes, use Godot Profiler/Debugger to verify pool reuse, FPS>60 at 200 enemies, memory stable over 5min continuous spawn/death cycles.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T02:11:22.111Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Duplicate/modify Red enemy scene; 2) Pool array initialization (50+30); 3) Spawn from pool logic; 4) Death/reset/return to pool; 5) Exhaustion handling and performance verification.",
        "updatedAt": "2026-01-07T02:11:22.111Z"
      },
      {
        "id": "16",
        "title": "Implement Enemy Death, Drops, and No-Inter-Collision",
        "description": "Add death handling with XP/Gold drops (Green:1/1, Red:3/2), particle effect, pool return. Ensure enemies pass through each other.",
        "details": "Enemy script: var current_hp. On damage: current_hp -= amount; if <=0: spawn_xp_gem(1 or 3), spawn_gold_coin(1 or 2), play_particles(), spawn_manager.return_to_pool(self). Area2D collision_layer=ENEMY_LAYER only collides with PLAYER_LAYER (bitmask), not self. No enemy-enemy collision.",
        "testStrategy": "Kill 50 Green/20 Red: verify correct drop counts, pool reuse (no new instances), enemies pass through each other (no bounce/block), particles play, all return to pool.",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement HP Tracking and Death Condition",
            "description": "Add current_hp variable to enemy script and damage handling logic that triggers death when HP <= 0.",
            "dependencies": [],
            "details": "Declare var current_hp: int = base_hp (use scaled values from task 12). In take_damage(amount: int) function: current_hp -= amount; if current_hp <= 0: handle_death(). Ensure integration with existing damage signals from weapons.",
            "status": "done",
            "testStrategy": "Apply damage to green/red enemies, verify HP decrements correctly and death triggers at exact threshold (10/25 base HP).",
            "updatedAt": "2026-01-07T20:41:34.374Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Drop Spawning for XP and Gold",
            "description": "Create spawn_xp_gem(amount) and spawn_gold_coin(amount) functions with enemy-type variants (Green:1/1, Red:3/2).",
            "dependencies": [
              1
            ],
            "details": "Preload XP gem and gold coin pickup scenes (reuse pooling from task 9). In handle_death(): if green: spawn_xp_gem(1), spawn_gold_coin(1); if red: spawn_xp_gem(3), spawn_gold_coin(2). Position drops at enemy global_position with slight random offset.",
            "status": "done",
            "testStrategy": "Kill 50 green/20 red enemies, count total XP/gold spawned (should be 50/60 XP gems, 50/40 coins), verify pickup collection works.",
            "parentId": "undefined",
            "updatedAt": "2026-01-07T23:56:12.462Z"
          },
          {
            "id": 3,
            "title": "Add Particle Effects and Pool Return",
            "description": "Play death particle effect on death and return enemy to spawn_manager pool.",
            "dependencies": [
              1
            ],
            "details": "Preload particle effect scene (one-shot GPUParticles2D like [5]). In handle_death(): instance particles at position, add to scene, auto queue_free when done. Call spawn_manager.return_to_pool(self) after particles. Reset current_hp on pool return.",
            "status": "pending",
            "testStrategy": "Observe particles play on every death, verify visual explosion effect, confirm enemies return to pool (no memory leaks, reuse instances).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure Collision Layers for No Enemy-Enemy Collision",
            "description": "Set Area2D collision_layer/mask so enemies only collide with player, pass through each other.",
            "dependencies": [],
            "details": "In enemy scene: Area2D collision_layer = ENEMY_LAYER (bit 1?), collision_mask = PLAYER_LAYER (bit 0?) only. Verify in Project Settings > Layer Names. Test grid partitioning from task 7 remains compatible.",
            "status": "done",
            "testStrategy": "Spawn 20+ enemies clustered together, confirm no bouncing/blocking between enemies, but all detect player collision normally.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T19:49:07.891Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into: 1) HP tracking and death condition; 2) Drop spawning (XP/Gold with variants); 3) Particle effects and pool return; 4) Collision layer/mask setup for no enemy-enemy collision.",
        "updatedAt": "2026-01-08T19:58:29.812Z"
      },
      {
        "id": "17",
        "title": "Design core weapon architecture and WeaponData Resource",
        "description": "Create the data-driven weapon architecture using Godot 4 Resources and define the WeaponData resource script to support all PRD fields and upgrade data.",
        "details": "Implementation details:\n- Engine: Godot 4.3+ (or latest stable 4.x) with GDScript 2.0 for best performance and tooling.\n- Create script `weapons/weapon_data.gd` extending `Resource` with `class_name WeaponData` exactly as in the PRD, adding typed exports for Godot 4:\n```gdscript\n# weapons/weapon_data.gd\nclass_name WeaponData\nextends Resource\n\n@export var id: String\n@export var display_name: String\n@export_multiline var description: String\n@export var base_damage: int\n@export var cooldown: float\n@export var weapon_type: String # \"projectile\", \"aoe\", \"melee\", \"orbital\"\n@export var sprite: Texture2D\n@export var icon: Texture2D\n@export var upgrades: Array[Dictionary] = [] # [{\"level\": int, \"damage\": int, \"effect_description\": String}]\n\n@export var debuff_type: String = \"\" # e.g. \"slow\", \"burn\"\n@export var debuff_duration: float = 0.0\n@export var debuff_strength: float = 0.0 # 0.5 = 50% slow\n@export var radius_modifier: float = 1.0\n@export var speed_modifier: float = 1.0\n@export var projectile_count: int = 1\n@export var pierce_count: int = 1\n\nfunc get_upgrade(level: int) -> Dictionary:\n\tfor u in upgrades:\n\t\tif int(u.get(\"level\", 0)) == level:\n\t\t\treturn u\n\treturn {}\n```\n- Use Godot 4 Resource workflows similar to recent modular weapon tutorials that use custom Resources to store weapon stats and behavior metadata.[1][2]\n- Create a folder structure: `res://weapons/data/` for `.tres` instances, `res://weapons/scripts/` for logic, `res://weapons/scenes/` for scenes.\n- Define 6 `.tres` WeaponData resources: Peck, Wing Slap, Feather Shot, Spiral Feathers, Ice Shard, Flame Wing. Populate base_damage, cooldown, weapon_type and upgrade arrays according to the PRD tables.\n- Encode upgrade effect text in `effect_description` but keep the actual gameplay effects implemented in weapon logic (damage scaling, radius, cooldown changes, pierce, projectile count, orbit size, etc.).\n- Ensure IDs are stable simple strings, e.g., \"peck\", \"wing_slap\", \"feather_shot\", \"spiral_feathers\", \"ice_shard\", \"flame_wing\".\n- Add a simple helper script or editor-only tool later (optional) to quickly create new WeaponData resources by duplicating existing ones, aligning with the 10–15 minutes per new weapon goal.\n- Plan for localization by making `display_name` and `description` text-based but keep actual localization for a later phase.\nSecurity / scalability considerations:\n- Data-only Resources avoid dynamic code loading, reducing security risks.\n- Keeping weapon definitions external allows easy balancing without code changes and keeps the weapon system scalable as the roster grows.\n",
        "testStrategy": "Manual and script-level tests:\n- In the Godot editor, create `.tres` WeaponData resources for all 6 weapons and verify fields are editable and saved properly.\n- Run a small test script in an autoload or temporary scene that loads each WeaponData (`load(\"res://weapons/data/peck.tres\")`) and prints id, base_damage, and all upgrade levels to the console.\n- Assert `get_upgrade(level)` returns the correct dictionary for levels 1–5 for each weapon; log an error if an upgrade is missing.\n- Confirm that changing values in the Inspector (e.g., damage, cooldown) updates when re-running the test script, ensuring fully data-driven configuration.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement WeaponData Resource script with all exported fields",
            "description": "Create the Godot 4 Resource script `weapons/weapon_data.gd` with `class_name WeaponData`, defining all exported properties and the `get_upgrade` helper as specified in the PRD and parent task details.",
            "dependencies": [],
            "details": "Use Godot 4.3+ and GDScript 2.0. Implement `WeaponData` extending `Resource` with typed `@export` properties: id, display_name, multiline description, base_damage, cooldown, weapon_type enum-like String, sprite and icon as Texture2D, upgrades as `Array[Dictionary]` with keys level, damage, effect_description, and additional combat fields (debuff_type, debuff_duration, debuff_strength, radius_modifier, speed_modifier, projectile_count, pierce_count). Implement `func get_upgrade(level: int) -> Dictionary` that iterates `upgrades` and returns the matching dictionary or an empty dictionary if not found. Ensure script compiles and appears as a custom resource type in the editor.",
            "status": "done",
            "testStrategy": "In the Godot editor, attach the script to a new Resource, verify all exported fields appear with correct types and tooltips, and call `get_upgrade` from the debugger or a simple test script to ensure it returns the correct dictionary for known levels.",
            "updatedAt": "2026-01-09T20:53:34.776Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Set up weapon folder structure and .tres workflow",
            "description": "Create a clean folder hierarchy and establish the workflow for authoring and managing WeaponData `.tres` resources in the Godot editor.",
            "dependencies": [
              1
            ],
            "details": "Create the folders `res://weapons/data/`, `res://weapons/scripts/`, and `res://weapons/scenes/` in the project. Move `weapon_data.gd` into `res://weapons/scripts/` or keep as specified, and ensure the custom Resource is discoverable when creating new resources. Define a standard naming convention for WeaponData `.tres` files (e.g., `peck.tres`, `wing_slap.tres`). Optionally draft a small editor-side helper or documented steps for creating new WeaponData resources by duplicating an existing one to support the 10–15 minutes per new weapon goal, while deferring full tooling implementation to a later task.",
            "status": "in-progress",
            "testStrategy": "In the Godot FileSystem panel, confirm the folders exist and appear correctly. Create a new Resource via the editor using type `WeaponData`, save it under `res://weapons/data/`, then reopen it to verify that edits persist and the workflow is straightforward.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T05:29:39.118Z"
          },
          {
            "id": 3,
            "title": "Author WeaponData .tres assets for the 6 initial weapons",
            "description": "Create and populate WeaponData `.tres` resources for Peck, Wing Slap, Feather Shot, Spiral Feathers, Ice Shard, and Flame Wing according to the PRD base stats and upgrade tables.",
            "dependencies": [
              1,
              2
            ],
            "details": "Within `res://weapons/data/`, create six `.tres` files using the WeaponData type: `peck.tres`, `wing_slap.tres`, `feather_shot.tres`, `spiral_feathers.tres`, `ice_shard.tres`, and `flame_wing.tres`. Set stable lowercase snake_case IDs (e.g., `peck`, `wing_slap`, etc.), and fill in display_name, description, base_damage, cooldown, weapon_type, sprite, icon, and all additional modifiers based on the PRD. Encode each level’s upgrade information as entries in the `upgrades` array of dictionaries, including `level`, new or incremental `damage` values, and human-readable `effect_description` text describing the upgrade effects, while leaving actual gameplay behavior (radius, cooldown, projectile count, pierce, orbit size, debuffs) to be handled in weapon logic scripts later.",
            "status": "pending",
            "testStrategy": "Open each WeaponData `.tres` in the editor and manually verify that all fields are set and consistent with the PRD. Optionally run a quick comparison script that loads all six resources and asserts presence of required keys (`id`, `base_damage`, `cooldown`, `weapon_type`, non-empty `upgrades`) to catch missing or malformed data.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build a test harness to load, validate, and log WeaponData behavior",
            "description": "Create a small test scene or autoload script that loads all WeaponData resources, validates required fields, and exercises `get_upgrade` to ensure data integrity.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement either a temporary test scene (e.g., `weapons/scenes/weapon_data_test.tscn`) with a script or an autoload singleton (e.g., `WeaponDataTester.gd`) that runs at startup. The script should scan `res://weapons/data/` or use a hardcoded list of the six `.tres` paths, load each WeaponData, and log key fields (id, display_name, base_damage, cooldown, weapon_type, number of upgrades). Add simple validation checks, such as non-empty id, cooldown > 0, and numeric types where expected, logging warnings for any invalid entries. Call `get_upgrade` for a range of levels (e.g., 1–5) per weapon and print or assert that it returns meaningful dictionaries for defined levels and an empty dictionary for undefined ones.",
            "status": "pending",
            "testStrategy": "Run the test scene or start the project with the tester autoload enabled. Inspect the output in the Godot console to confirm all six WeaponData assets load without errors, validation passes (or clearly reports issues), and `get_upgrade` returns correct data for each defined upgrade level while safely handling missing levels.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break Task 17 into ~4 subtasks covering: (1) creating the WeaponData Resource script and exports, (2) setting up folder structure and .tres asset workflow, (3) encoding all PRD-based stats/upgrades for the 6 initial weapons, and (4) building a small test harness (scene or autoload script) to load, validate, and log WeaponData, including get_upgrade behavior.",
        "updatedAt": "2026-01-10T05:29:39.118Z"
      },
      {
        "id": "18",
        "title": "Implement base Weapon node with cooldown and upgrade handling",
        "description": "Create an abstract Weapon base class that handles cooldown timing, level progression, and integrates with WeaponData to compute effective stats.",
        "details": "Implementation details:\n- Create `weapons/scripts/weapon.gd` as a base script with `class_name Weapon` and attach it to a generic weapon scene `weapons/scenes/weapon_base.tscn` using `Node2D` as root.\n- Base node structure:\n  - `Node2D` (Weapon)\n    - Optional `Timer` (cooldown_timer) or use `_process` with delta.\n- In Godot 4, using `Timer` with `one_shot = true` and `start(cooldown)` is reliable; but for always-ready if `cooldown <= 0`, skip timer.\n- Script outline:\n```gdscript\nclass_name Weapon\nextends Node2D\n\n@export var weapon_data: WeaponData\nvar level: int = 1\nvar current_cooldown: float\nvar damage: int\nvar ready: bool = true\n\nfunc _ready() -> void:\n\tassert(weapon_data != null)\n\t_apply_level_stats()\n\nfunc _apply_level_stats() -> void:\n\tvar upgrade := weapon_data.get_upgrade(level)\n\tif upgrade.is_empty():\n\t\tdamage = weapon_data.base_damage\n\telse:\n\t\tdamage = int(upgrade.get(\"damage\", weapon_data.base_damage))\n\t# Allow subclasses to react (e.g., radius, projectile_count)\n\t_on_stats_changed(upgrade)\n\nfunc _on_stats_changed(upgrade: Dictionary) -> void:\n\tpass # virtual, overridden by subclasses\n\nfunc try_fire() -> void:\n\tif not ready:\n\t\treturn\n\tif _do_fire():\n\t\t_start_cooldown()\n\nfunc _do_fire() -> bool:\n\t# virtual; return true if fired\n\treturn false\n\nfunc _start_cooldown() -> void:\n\tready = false\n\tvar cd := weapon_data.cooldown\n\t# Subclasses may override or modify via stats\n\tcurrent_cooldown = cd\n\tif current_cooldown <= 0.0:\n\t\tready = true\n\t\treturn\n\tvar t := Timer.new()\n\tt.one_shot = true\n\tt.wait_time = current_cooldown\n\tadd_child(t)\n\tt.timeout.connect(_on_cooldown_done)\n\tt.start()\n\nfunc _on_cooldown_done() -> void:\n\tready = true\n\nfunc set_level(new_level: int) -> void:\n\tlevel = clamp(new_level, 1, 5)\n\t_apply_level_stats()\n```\n- Choose per-fire `Timer` nodes or a single reusable timer; for simplicity and directness, create a single `Timer` child in the scene and reuse it rather than spawning new ones each time.\n- Modify `_start_cooldown()` accordingly to use a pre-existing `cooldown_timer` child.\n- Provide safe virtual hooks for child classes: `_on_stats_changed`, `_do_fire`.\n- Base class should not know about player or enemies; specific weapon types will use references passed by the WeaponManager.\n- Ensure level upgrades are idempotent and that changing levels at runtime updates all computed stats correctly.\n",
        "testStrategy": "Unit-like tests in a small test scene:\n- Create a `weapon_base_test.tscn` with a Weapon node referencing the Peck WeaponData.\n- On `_ready`, call `try_fire()` and verify via logging that `_do_fire` (temporarily implemented to print) only runs when `ready == true` and subsequent `try_fire()` calls within cooldown do nothing.\n- Adjust `weapon_data.cooldown` to 0.1 and verify cooldown resets properly.\n- Call `set_level()` for levels 1–5 and log damage to confirm values follow the WeaponData upgrade table.\n- Add asserts in debug builds to ensure `weapon_data` is never null and `level` always in 1–5 range.",
        "priority": "high",
        "dependencies": [
          "17"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 18 into ~5 subtasks: (1) define the Weapon base script and scene (node structure, exported WeaponData), (2) implement cooldown handling with a reusable Timer and ready/try_fire flow, (3) implement level and upgrade application including virtual hooks, (4) enforce assertions/guards and idempotent runtime level changes, and (5) create a dedicated test scene or scripts to validate cooldown timing and upgrade-derived stats."
      },
      {
        "id": "19",
        "title": "Create WeaponManager to track and auto-fire up to 6 weapons",
        "description": "Implement a WeaponManager node that owns equipped weapons, enforces the 6-weapon limit, and triggers automatic firing when cooldowns are ready.",
        "details": "Implementation details:\n- Create `weapons/scripts/weapon_manager.gd` and a scene `weapons/scenes/weapon_manager.tscn` with root `Node2D`.\n- Attach WeaponManager as a child of the Player root (from Core Foundation), so it has access to player position and facing direction.\n- WeaponManager responsibilities:\n  - Store up to 6 weapon instances.\n  - Instantiate weapon scenes based on WeaponData (and child class/scene mapping by type or id).\n  - Position weapons relative to the player as needed (most will use player global_position but may not need visible nodes during placeholder phase).\n  - Auto-fire all weapons each frame or at fixed intervals.\n- Script sketch:\n```gdscript\nclass_name WeaponManager\nextends Node2D\n\nconst MAX_WEAPONS := 6\n\nvar weapons: Array[Weapon] = []\nvar player: Node2D\n\nfunc _ready() -> void:\n\tplayer = get_parent() as Node2D\n\nfunc add_weapon(data: WeaponData) -> Weapon:\n\tif weapons.size() >= MAX_WEAPONS:\n\t\treturn null\n\tvar scene := _get_weapon_scene_for_data(data)\n\tvar weapon := scene.instantiate() as Weapon\n\tweapon.weapon_data = data\n\tweapon.set_level(1)\n\tadd_child(weapon)\n\tweapons.append(weapon)\n\treturn weapon\n\nfunc _process(delta: float) -> void:\n\tfor weapon in weapons:\n\t\t# Optionally update weapon target/facing from player\n\t\tweapon.global_position = player.global_position\n\t\tif weapon.ready:\n\t\t\tweapon.try_fire()\n\nfunc get_weapon_by_id(id: String) -> Weapon:\n\tfor w in weapons:\n\t\tif w.weapon_data.id == id:\n\t\t\treturn w\n\treturn null\n\nfunc upgrade_weapon(id: String) -> void:\n\tvar w := get_weapon_by_id(id)\n\tif w:\n\t\tw.set_level(w.level + 1)\n```\n- Implement `_get_weapon_scene_for_data(data: WeaponData)` using either a match on `data.id` or a `Dictionary` mapping id → PackedScene exported on WeaponManager for flexibility.\n- Integration with progression/level-up system (from Feature 4) will call `add_weapon` or `upgrade_weapon` based on choices; ensure that when 6 weapons are owned, only upgrades are offered via higher-level system (outside WeaponManager but relying on its state).\n- For initial placeholder art, attach simple `ColorRect` or `Sprite2D` nodes to each weapon scene, not to the WeaponManager.\n- Follow best practice from recent Godot community discussions on weapon managers where all weapons inherit from a base Weapon class and are managed centrally.[6][9]\n",
        "testStrategy": "Gameplay-level tests in a debug scene:\n- Create a test Player + WeaponManager scene, preload the 4 unique weapon WeaponData resources, and on `_ready` call `add_weapon` for each.\n- Log `weapons.size()` and ensure it does not exceed 6 if attempting to add more than MAX_WEAPONS.\n- Temporarily implement `_do_fire()` in base Weapon to print the weapon id and timestamp; run the scene and verify that prints occur at correct cooldown intervals per weapon type.\n- Move the player around and confirm that each weapon’s `global_position` tracks the player.\n- Simulate upgrade calls and check that weapon levels and damage update correctly, without creating duplicate instances.",
        "priority": "high",
        "dependencies": [
          "17",
          "18"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 19 into ~5 subtasks: (1) create the WeaponManager scene/script and attach it to the player, (2) implement weapon instantiation and scene lookup/mapping from WeaponData, (3) implement auto-fire loop, positioning, and readiness checks, (4) add querying/upgrade APIs (get_weapon_by_id, upgrade_weapon, capacity checks), and (5) build a test setup that spawns several weapons, verifies auto-fire cadence, and enforces the 6-weapon limit."
      },
      {
        "id": "20",
        "title": "Implement melee cone weapon: Peck",
        "description": "Create the Peck melee weapon as a cone attack in the facing direction, using Area2D for damage detection and supporting level-based damage, arc, and cooldown changes.",
        "details": "Implementation details:\n- Create scene `weapons/scenes/peck.tscn`:\n  - Root: `Node2D` with script `peck_weapon.gd` extending `Weapon`.\n  - Child: `Area2D` (`hit_area`)\n    - `CollisionShape2D` with `ArcShape2D` or a pie-shaped polygon via `CollisionPolygon2D` representing a small cone in front of the player.\n    - Use collision layer/mask to detect enemies only (cooperate with Enemy System’s layers).\n  - Child: placeholder `ColorRect` or `Sprite2D` for hit effect (32x32) oriented forward.\n- In `peck_weapon.gd`:\n```gdscript\nclass_name PeckWeapon\nextends Weapon\n\n@onready var hit_area: Area2D = $HitArea\n\nfunc _on_stats_changed(upgrade: Dictionary) -> void:\n\t# Level 4: faster cooldown (0.4s)\n\tif level >= 4:\n\t\tweapon_data.cooldown = 0.4\n\t# Level 5: wider arc -> adjust collision shape angle\n\tvar shape := hit_area.get_node(\"CollisionShape2D\").shape\n\tif shape is ArcShape2D:\n\t\tshape.angle = deg_to_rad(level >= 5 ? 80.0 : 50.0)\n\t# Damage already handled in base class\n\nfunc _do_fire() -> bool:\n\t# Align cone with player facing (assume player has a direction vector or rotation)\n\tvar player := (get_parent() as Node2D).get_parent() as Node2D # or injected reference\n\tglobal_rotation = player.global_rotation\n\t# Optionally briefly enable hit_area monitoring\n\tvar enemies := hit_area.get_overlapping_bodies()\n\tfor e in enemies:\n\t\tif e.has_method(\"apply_damage\"):\n\t\t\te.apply_damage(damage, weapon_data)\n\t# Trigger simple visual effect (e.g., briefly show ColorRect)\n\treturn true\n```\n- Use `Area2D.monitoring = true` and `get_overlapping_bodies()`; ensure physics layers are set to match enemies.\n- Damage numbers come from `damage` computed based on WeaponData upgrades (Level 1–5: 10, 15, 20, 25, 35).\n- For facing direction, rely on an injected direction or use player rotation; adapt to how the Player from Feature 1 exposes facing (e.g., `velocity.normalized()` or mouse direction), but keep this minimal for now.\n- Ensure the Peck WeaponData cooldown is 0.5s base, with logic for 0.4s at level 4.\n",
        "testStrategy": "In an arena-style test scene:\n- Place a Player with WeaponManager, spawn a few dummy enemy nodes with an `apply_damage(amount, weapon_data)` method that logs damage.\n- Add the Peck weapon via WeaponManager.\n- Spawn enemies in front of and behind the player to verify that only those in the cone receive damage when Peck fires.\n- Adjust weapon level from 1 to 5 and verify via logs:\n  - Damage values: 10, 15, 20, 25, 35.\n  - Cooldown decreases at level 4 (measure time between hits in logs).\n  - Arc width increases at level 5 (more enemies at wider angles are hit).\n- Confirm that enemies behind or far outside the radius never receive damage.",
        "priority": "high",
        "dependencies": [
          "18",
          "19"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break Task 20 into ~4 subtasks: (1) build the Peck scene (Node2D, Area2D, collision shape, placeholder visual, layers/masks), (2) implement peck_weapon.gd extending Weapon with stats reaction and cooldown/arc changes across levels, (3) implement firing logic including player facing alignment and enemy hit detection, and (4) create an arena test scene validating cone coverage, damage values per level, and cooldown/arc scaling."
      },
      {
        "id": "21",
        "title": "Implement AOE circle weapons: Wing Slap and Flame Wing clone",
        "description": "Create a reusable AOE circle weapon implementation for Wing Slap and a clone configuration for Flame Wing with different radius and damage using shared logic.",
        "details": "Implementation details:\n- Create generic AOE weapon script `aoe_circle_weapon.gd` extending `Weapon`, and scene `weapons/scenes/aoe_circle_weapon.tscn`:\n  - Root `Node2D` with `Area2D` child (`aoe_area`) and `CollisionShape2D` using `CircleShape2D`.\n  - Placeholder `ColorRect` or `Sprite2D` (64x64) representing an expanding circle; use `AnimationPlayer` for a quick scale animation.\n- `aoe_circle_weapon.gd` outline:\n```gdscript\nclass_name AOECircleWeapon\nextends Weapon\n\n@export var base_radius: float = 48.0\n@onready var aoe_area: Area2D = $AOEArea\n@onready var shape: CircleShape2D = $AOEArea/CollisionShape2D.shape\n\nfunc _ready() -> void:\n\tshape.radius = base_radius\n\tsuper._ready()\n\nfunc _on_stats_changed(upgrade: Dictionary) -> void:\n\t# Damage handled by base\n\t# Level-based radius scaling is done via WeaponData.radius_modifier if needed\n\tvar r_mod := weapon_data.radius_modifier\n\tshape.radius = base_radius * r_mod\n\nfunc _do_fire() -> bool:\n\t# Play quick expand animation (optional) and damage all enemies in area\n\tvar enemies := aoe_area.get_overlapping_bodies()\n\tfor e in enemies:\n\t\tif e.has_method(\"apply_damage\"):\n\t\t\te.apply_damage(damage, weapon_data)\n\treturn true\n```\n- Create two scenes inheriting from `aoe_circle_weapon.tscn`:\n  - `wing_slash_weapon.tscn` (Wing Slap)\n  - `flame_wing_weapon.tscn` (Flame Wing)\n- Wing Slap tuning per PRD:\n  - Base cooldown 1.5s, base damage 8.\n  - Upgrades: damage 8, 12, 16, 20, 28; radius increases at levels 3 and 5.\n  - Represent radius changes by modifying `radius_modifier` in WeaponData and reading it in `_on_stats_changed`.\n- Flame Wing clone:\n  - Uses the same `AOECircleWeapon` script and scene structure.\n  - WeaponData: base damage 10 (+20% vs Wing Slap base 8), cooldown 1.5s, radius modifier 0.75 relative to Wing Slap (75% radius) for all levels.\n  - Optionally increase radius slightly with level if desired, but base difference should remain smaller than Wing Slap.\n  - Assign an orange/red placeholder color or sprite to distinguish it.\n- In WeaponManager’s `_get_weapon_scene_for_data`, map Wing Slap and Flame Wing IDs to these respective scenes, keeping logic DRY.\n",
        "testStrategy": "In a combat sandbox scene:\n- Spawn several enemies around the player at different distances to verify AOE radius.\n- Add Wing Slap, let it auto-fire, and log which enemies are damaged; measure approximate radius by observing which enemies at known distances are hit.\n- Upgrade Wing Slap to levels 3 and 5 and ensure the radius increases are visible (more distant enemies hit) and that damage follows the upgrade table.\n- Add Flame Wing instead of Wing Slap and verify:\n  - Damage values are consistently 20% higher at base (and scaled by upgrades if configured).\n  - The effective radius is about 75% of Wing Slap (fewer distant enemies hit) using the same enemy positions.\n- Confirm both weapons respect the 1.5s cooldown and do not fire more frequently than expected.",
        "priority": "high",
        "dependencies": [
          "18",
          "19"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 21 into ~5 subtasks: (1) implement the generic AOECircleWeapon scene and script (Area2D, CircleShape2D, AnimationPlayer), (2) wire radius and damage scaling via WeaponData and _on_stats_changed, (3) create Wing Slap derived scene and configure its WeaponData including radius modifiers per level, (4) create Flame Wing clone configuration using shared script with altered damage/radius visuals, and (5) build a sandbox test scene to validate radius, damage progression, cooldown, and DRY mapping in WeaponManager."
      },
      {
        "id": "22",
        "title": "Implement projectile weapons: Feather Shot and Ice Shard clone",
        "description": "Create a projectile weapon system for Feather Shot that fires toward the nearest enemy with pierce and multi-projectile upgrades, then configure Ice Shard as a slower projectile clone applying a slow debuff.",
        "details": "Implementation details:\n- Projectile node setup:\n  - Create `weapons/scenes/projectile.tscn`:\n    - Root: `Area2D` (`Projectile`)\n      - `CollisionShape2D` (CircleShape2D or small rectangle)\n      - `Sprite2D` placeholder (16x16 for feathers).\n  - Script `projectile.gd`:\n```gdscript\nclass_name Projectile\nextends Area2D\n\nvar speed: float = 150.0\nvar damage: int = 0\nvar pierce_remaining: int = 1\nvar direction: Vector2 = Vector2.RIGHT\nvar weapon_data: WeaponData\n\nfunc _ready() -> void:\n\tarea_entered.connect(_on_area_entered)\n\tbody_entered.connect(_on_body_entered)\n\nfunc _physics_process(delta: float) -> void:\n\tglobal_position += direction * speed * delta\n\t# Optional: queue_free when off-screen using a VisibilityNotifier2D\n\nfunc _hit_target(target: Node) -> void:\n\tif target.has_method(\"apply_damage\"):\n\t\ttarget.apply_damage(damage, weapon_data)\n\t# Apply debuff if present in weapon_data\n\tif weapon_data.debuff_type != \"\" and target.has_method(\"apply_debuff\"):\n\t\ttarget.apply_debuff(weapon_data.debuff_type, weapon_data.debuff_strength, weapon_data.debuff_duration)\n\tpierce_remaining -= 1\n\tif pierce_remaining <= 0:\n\t\tqueue_free()\n\nfunc _on_body_entered(body: Node) -> void:\n\t_hit_target(body)\n\nfunc _on_area_entered(area: Area2D) -> void:\n\t# If enemies are Areas in your enemy system, handle similarly\n\t_hit_target(area)\n```\n- Feather Shot weapon:\n  - Scene `weapons/scenes/feather_shot_weapon.tscn` with script `feather_shot_weapon.gd` extending `Weapon`.\n  - Export `PackedScene` for projectile to reuse across weapons.\n  - On `_do_fire()`, query nearest enemy from Enemy System (e.g., via a global EnemyManager singleton, or by scanning a group `\"enemies\"`).\n  - Compute direction: `direction = (enemy.global_position - global_position).normalized()`.\n  - Spawn `weapon_data.projectile_count` projectiles; for multiple shots, optionally fan them slightly around the main direction.\n  - Level effects:\n    - Level 1–3: projectile_count = 1, 2, 3.\n    - Level 4: pierce_count = 2.\n    - Level 5: projectile_count = 4, pierce_count = 3.\n  - Implement `_on_stats_changed(upgrade)` to set projectile_count and pierce from level, using weapon_data fields or computed in code:\n```gdscript\nfunc _on_stats_changed(upgrade: Dictionary) -> void:\n\tmatch level:\n\t\t1:\n\t\t\tweapon_data.projectile_count = 1\n\t\t\tweapon_data.pierce_count = 1\n\t\t2:\n\t\t\tweapon_data.projectile_count = 2\n\t\t3:\n\t\t\tweapon_data.projectile_count = 3\n\t\t4:\n\t\t\tweapon_data.pierce_count = 2\n\t\t5:\n\t\t\tweapon_data.projectile_count = 4\n\t\t\tweapon_data.pierce_count = 3\n```\n  - When instantiating a projectile:\n```gdscript\nvar p := projectile_scene.instantiate() as Projectile\np.global_position = global_position\np.direction = direction\np.speed = 150.0 * weapon_data.speed_modifier\np.damage = damage\np.pierce_remaining = weapon_data.pierce_count\np.weapon_data = weapon_data\nget_tree().current_scene.add_child(p)\n```\n- Ice Shard clone:\n  - Uses the same Feather Shot weapon script and projectile scene (clone behavior).\n  - WeaponData differences:\n    - Blue-tinted sprite (recolor) for the projectile texture.\n    - `speed_modifier = 100.0 / 150.0` (~0.666) to make projectile slower.\n    - `debuff_type = \"slow\"`, `debuff_duration = 0.5`, `debuff_strength = 0.5` (50% slow).\n    - Base damage 10, cooldown 1.2s.\n  - No change to code required; Projectile will apply debuff automatically based on WeaponData.\n- Industry practice from recent Godot weapon system tutorials recommends central projectile scenes and modular weapons using Resources, which this follows.[1][2]\n",
        "testStrategy": "In a projectile test scene:\n- Place a Player with WeaponManager and spawn a line of enemies at various distances.\n- Add Feather Shot and log projectile spawns: ensure one projectile at level 1, and correct counts at levels 2–5.\n- Confirm that projectiles travel across the screen, pierce the configured number of enemies, and despawn properly when pierce is exhausted or they leave the play area.\n- Measure approximate fire rate to confirm 1.0s cooldown.\n- Switch to Ice Shard WeaponData on the same weapon scene:\n  - Compare projectile speed visually and via logging distance traveled per second; confirm it is slower than Feather Shot.\n  - Confirm that hit enemies have an `apply_debuff` call with type \"slow\", strength 0.5, duration 0.5s.\n  - Temporary implementation of `apply_debuff` on enemies should reduce their movement speed by 50% and restore it after 0.5s; observe this behavior in-game.\n- Verify that both weapons share the same underlying code (no duplicate weapon scripts), validating the clone approach.",
        "priority": "high",
        "dependencies": [
          "18",
          "19",
          "17"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break Task 22 into ~6 subtasks: (1) create the generic Projectile scene and script with movement, hit detection, pierce, and optional debuff forwarding, (2) implement Feather Shot weapon scene/script integrating with Enemy query to target nearest enemy and spawn multiple projectiles, (3) handle per-level behavior (projectile_count, pierce_count, speed modifiers) via WeaponData and _on_stats_changed, (4) configure Ice Shard as a data-driven clone with slower speed and slow debuff parameters, (5) integrate projectiles into the main scene tree/lifecycle (despawning, off-screen handling), and (6) build a projectile test scene to verify counts, pierce behavior, cooldown, and debuff triggering."
      },
      {
        "id": "23",
        "title": "Implement Spiral Feathers orbital weapon",
        "description": "Create the Spiral Feathers orbital weapon with always-active orbiting projectiles that damage enemies on contact, scaling damage, rotation speed, feather count, and orbit radius by level.",
        "details": "Implementation details:\n- Scene `weapons/scenes/spiral_feathers_weapon.tscn`:\n  - Root: `Node2D` with script `spiral_feathers_weapon.gd` extending `Weapon`.\n  - Child `Node2D` (`OrbitRoot`) to act as rotation pivot around the player.\n- For each feather:\n  - Use either the same `Projectile` scene with modified behavior, or a simpler `Area2D`-based `OrbitalFeather` scene, since orbitals are passive and do not move linearly.\n  - To keep things simple and direct, create `OrbitalFeather` scene:\n    - Root `Area2D` with `CollisionShape2D` and `Sprite2D` (reusing the Feather Shot sprite, rotated).\n    - Script `orbital_feather.gd` with:\n```gdscript\nclass_name OrbitalFeather\nextends Area2D\n\nvar damage: int = 0\nvar weapon_data: WeaponData\n\nfunc _ready() -> void:\n\tbody_entered.connect(_on_body_entered)\n\tarea_entered.connect(_on_area_entered)\n\nfunc _hit(target: Node) -> void:\n\tif target.has_method(\"apply_damage\"):\n\t\ttarget.apply_damage(damage, weapon_data)\n\nfunc _on_body_entered(body: Node) -> void:\n\t_hit(body)\n\nfunc _on_area_entered(area: Area2D) -> void:\n\t_hit(area)\n```\n- In `spiral_feathers_weapon.gd`:\n  - Maintain:\n```gdscript\n@export var feather_scene: PackedScene\nvar orbit_speed: float = 1.0 # radians/sec\nvar orbit_radius: float = 32.0\nvar feather_count: int = 4\nvar feathers: Array[OrbitalFeather] = []\n```\n  - Override `_ready()` to spawn feathers based on current `feather_count`.\n  - In `_process(delta)`, rotate `OrbitRoot` around the player:\n```gdscript\nfunc _process(delta: float) -> void:\n\tvar player := (get_parent() as Node2D).get_parent() as Node2D\n\tglobal_position = player.global_position\n\t$OrbitRoot.rotation += orbit_speed * delta\n```\n  - When spawning each feather, position it around the OrbitRoot:\n```gdscript\nfunc _spawn_feathers() -> void:\n\tfor f in feathers:\n\t\tf.queue_free()\n\tfeathers.clear()\n\tfor i in range(feather_count):\n\t\tvar feather := feather_scene.instantiate() as OrbitalFeather\n\t\tfeather.damage = damage\n\t\tfeather.weapon_data = weapon_data\n\t\tvar angle := TAU * float(i) / float(feather_count)\n\t\tfeather.position = Vector2.RIGHT.rotated(angle) * orbit_radius\n\t\t$OrbitRoot.add_child(feather)\n\t\tfeathers.append(feather)\n```\n  - Override `_on_stats_changed(upgrade)` to update damage, orbit_speed, orbit_radius, and feather_count per level:\n    - Level 1: 4 feathers, base damage 6, base orbit_radius (e.g., 32), base orbit_speed.\n    - Level 2: damage 8.\n    - Level 3: faster rotation (increase orbit_speed by ~33%).\n    - Level 4: 6 feathers.\n    - Level 5: 8 feathers, larger orbit (e.g., radius * 1.3).\n  - Always keep `Weapon.ready = true` and cooldown set to 0 for passive weapons; override `try_fire()` or `_do_fire()` to do nothing since it is always active.\n- Reuse the Feather Shot projectile sprite texture for the orbital feathers for consistency, as required by the PRD.\n",
        "testStrategy": "In a dedicated orbital test scene:\n- Add Spiral Feathers via WeaponManager and spawn dummy enemies that move toward the player.\n- Observe that enemies touching the orbitals take damage via `apply_damage`, logged to the console.\n- At each level from 1 to 5, verify:\n  - Damage matches the table: 6, 8, 10, 12, 16.\n  - Feather count: 4, 4, 4, 6, 8.\n  - Rotation speed visibly increases at level 3.\n  - Orbit radius increases at level 5 such that enemies slightly farther away are hit.\n- Confirm that the weapon remains active without any visible cooldown and that feathers follow the player smoothly across the map.",
        "priority": "medium",
        "dependencies": [
          "18",
          "19",
          "17"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 23 into ~5 subtasks: (1) create the OrbitalFeather scene and script for passive collision-based damage, (2) build the Spiral Feathers weapon scene with OrbitRoot and integrate with Weapon base class, (3) implement orbit logic (player-following, rotation, radius) and always-active behavior without cooldown, (4) implement level-based scaling of damage, orbit_speed, feather_count, and orbit_radius, including respawn/update of feathers, and (5) create an orbital test scene to validate contact damage, scaling behaviors, and movement smoothness around the player."
      },
      {
        "id": "24",
        "title": "Implement debuff system for slow and future effects",
        "description": "Create a lightweight debuff system that allows projectiles and weapons to apply time-limited debuffs like slow or burn to enemies, starting with slow for Ice Shard.",
        "details": "Implementation details:\n- Aim for a simple, extensible debuff component attached to enemies, avoiding over-engineering but allowing slow and later burn.\n- Create `debuff.gd` as a simple data structure (Resource or class):\n```gdscript\nclass_name Debuff\nextends Resource\n\n@export var debuff_type: String\n@export var strength: float\n@export var duration: float\nvar elapsed: float = 0.0\n```\n- Create `debuff_handler.gd` to be attached to enemy scenes:\n```gdscript\nclass_name DebuffHandler\nextends Node\n\nvar active_debuffs: Array[Debuff] = []\n\nfunc apply_debuff(debuff_type: String, strength: float, duration: float) -> void:\n\tif duration <= 0.0:\n\t\treturn\n\tvar d := Debuff.new()\n\td.debuff_type = debuff_type\n\td.strength = strength\n\td.duration = duration\n\tactive_debuffs.append(d)\n\nfunc _process(delta: float) -> void:\n\tfor d in active_debuffs:\n\t\td.elapsed += delta\n\tactive_debuffs = active_debuffs.filter(func(x: Debuff) -> bool:\n\t\treturn x.elapsed < x.duration)\n\nfunc get_total_slow_factor() -> float:\n\tvar factor := 1.0\n\tfor d in active_debuffs:\n\t\tif d.debuff_type == \"slow\":\n\t\t\tfactor *= (1.0 - d.strength)\n\treturn clamp(factor, 0.2, 1.0)\n```\n- Integrate with Enemy movement (from Enemy System PRD):\n  - Where enemies compute their speed or velocity, multiply their base speed by `debuff_handler.get_total_slow_factor()` if a DebuffHandler is present.\n- Ensure `Projectile._hit_target` calls `target.apply_debuff()`; wire this method on the enemy root to forward to DebuffHandler:\n```gdscript\nfunc apply_debuff(debuff_type: String, strength: float, duration: float) -> void:\n\tif $DebuffHandler:\n\t\t$DebuffHandler.apply_debuff(debuff_type, strength, duration)\n```\n- This allows any weapon that sets `WeaponData.debuff_type`, `debuff_duration`, and `debuff_strength` to apply debuffs automatically.\n- Focus now only on slow debuff used by Ice Shard, but keep `debuff_type` string-based to later handle \"burn\" (e.g., periodic damage) without system redesign.\n",
        "testStrategy": "Integration tests with Ice Shard and enemies:\n- In an enemy test scene, equip an enemy with DebuffHandler and basic AI that moves toward the player at a fixed base speed.\n- Fire Ice Shard projectiles at the enemy; on hit, log application of debuff and current total slow factor.\n- Confirm that for a 50% slow (`strength = 0.5`), the enemy’s effective speed is roughly half the base speed for 0.5 seconds, then returns to normal.\n- Apply multiple slows in quick succession and ensure that the combined slow factor is capped (e.g., not below 20% of base speed) and that debuffs expire correctly after their duration.\n- Ensure that weapons without debuff configuration do not affect enemy speed or other stats.",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break Task 24 into ~4 subtasks: (1) implement the Debuff Resource and DebuffHandler node with lifetime and stacking logic, (2) integrate DebuffHandler into enemy scenes and expose an apply_debuff API on enemies, (3) wire Projectile._hit_target to call enemy debuff application based on WeaponData fields, and (4) create focused tests with Ice Shard and dummy enemies to validate slow factors, stacking, expiration, and non-impact for weapons without debuffs."
      },
      {
        "id": "25",
        "title": "Integrate weapon acquisition and upgrade flow with progression system",
        "description": "Connect the WeaponManager with the existing level-up/progression system to handle acquiring new weapons, enforcing the 6-weapon limit, and offering only upgrades when full.",
        "details": "Implementation details:\n- Work with the Progression Systems PRD (Features 4–6) to determine where level-up choices are generated; typically there is a LevelUp UI or ChoiceManager.\n- Extend the progression code to query WeaponManager state when generating level-up options:\n  - If `weapons.size() < MAX_WEAPONS`, include both new weapon options (WeaponData not yet owned) and upgrade `+1` options for existing weapons.\n  - If `weapons.size() >= MAX_WEAPONS`, only offer `+1` upgrade options for weapons already owned.\n- Implementation outline in a central LevelUpManager:\n```gdscript\nfunc get_weapon_choices() -> Array:\n\tvar choices: Array = []\n\tvar owned_ids := weapon_manager.weapons.map(func(w): return w.weapon_data.id)\n\tvar all_weapon_datas := _get_all_weapon_datas()\n\tvar can_add_new := weapon_manager.weapons.size() < WeaponManager.MAX_WEAPONS\n\tif can_add_new:\n\t\t# Include some unowned weapons\n\t\tvar unowned := all_weapon_datas.filter(func(d: WeaponData): return not owned_ids.has(d.id))\n\t\tchoices += _pick_random(unowned, desired_new_count)\n\t# Always include upgrade options for owned weapons\n\tvar upgradable := weapon_manager.weapons.filter(func(w: Weapon): return w.level < 5)\n\tchoices += upgradable\n\treturn choices\n```\n- On selection:\n  - If choice is a WeaponData not currently owned, call `weapon_manager.add_weapon(weapon_data)`.\n  - If choice refers to an existing Weapon, call `weapon_manager.upgrade_weapon(id)`.\n- Ensure that Peck as the starting weapon is always granted at game start:\n  - On Player initialization, call `weapon_manager.add_weapon(peck_weapon_data)` and set its level to 1.\n- Keep this logic data-driven by obtaining all WeaponData via a simple registry or resource list (e.g., an exported `Array[WeaponData]` on a central `WeaponDatabase` node).\n- Ensure there is no path in the UI to acquire more than 6 weapons; LevelUpManager should never offer a new weapon if at capacity.\n",
        "testStrategy": "End-to-end progression tests:\n- Start a new game and verify that the player always has Peck at level 1.\n- Simulate several level-ups with fewer than 6 weapons owned:\n  - Confirm that new weapon options appear and can be chosen to add Wing Slap, Feather Shot, etc.\n- Once 6 weapons are owned, trigger additional level-ups:\n  - Confirm that the UI only shows `+1` upgrade options (no new weapons) and that selecting them correctly increases weapon levels up to 5.\n- Attempt to force-add a 7th weapon by calling `add_weapon` directly in a debug console or script and confirm that WeaponManager rejects it (returns null) and the weapon count remains 6.\n- Verify that weapon upgrades never increase level beyond 5 and that stats still update correctly at maximum level.",
        "priority": "medium",
        "dependencies": [
          "19",
          "20",
          "21",
          "22",
          "23"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 25 into ~5 subtasks: (1) analyze existing progression/level-up code and define integration points with WeaponManager, (2) implement a WeaponDatabase/registry of WeaponData resources for choice generation, (3) implement choice-generation logic that respects MAX_WEAPONS, ownership, and upgrade caps, (4) hook level-up UI selection events to call WeaponManager.add_weapon/upgrade_weapon and update state, and (5) create end-to-end tests or scripted flows to verify starting Peck, new-weapon vs upgrade options, capacity enforcement, and max-level handling."
      },
      {
        "id": "26",
        "title": "Implement placeholder visuals and damage Areas for all weapon types",
        "description": "Wire up placeholder ColorRect/Sprite2D visuals and Area2D hit detection for all weapons to ensure clear feedback during Weeks 1–3 before final art arrives.",
        "details": "Implementation details:\n- For consistency across the system, review each weapon scene (Peck, Wing Slap, Flame Wing, Feather Shot, Ice Shard, Spiral Feathers) and ensure:\n  - Each uses `Area2D` with appropriate `CollisionShape2D` sized to match the intended gameplay effect.\n  - Each has a placeholder visual:\n    - Peck: 32x32 ColorRect or Sprite2D, offset in front of player, oriented with facing direction.\n    - Wing Slap: 64x64 ColorRect or circular Sprite2D centered on player, quick fade/scale animation.\n    - Flame Wing: Same as Wing Slap but orange/red color to distinguish.\n    - Feather Shot / Ice Shard: 16x16 ColorRect or Sprite2D for projectiles; Ice Shard tinted blue.\n    - Spiral Feathers: 16x16 orbital sprites reusing projectile sprite geometry.\n- Use Godot 4’s `CanvasItem` modulate property for easy color-tinting clones.\n- Ensure that all Area2D nodes are set to the correct physics layers/masks to detect enemies and ignore players/other projectiles.\n- Add simple one-shot animations using `AnimationPlayer` where appropriate (e.g., scaling AOE effects) but keep them minimal to avoid scope creep.\n- Keep the visual implementation decoupled from logic (Weapon and Projectile scripts should not depend on final art assets, only on node names/types), so that art integration later is just a matter of replacing textures.\n",
        "testStrategy": "Visual and collision verification:\n- Run a debug arena scene with all 6 weapons equipped and check:\n  - Peck’s hit cone appears in front of the player with correct orientation.\n  - Wing Slap and Flame Wing circles are clearly visible and do not obscure the player entirely.\n  - Feather/Ice projectiles are easy to see against the background, and Ice Shard is visibly different in color.\n  - Spiral feathers orbit smoothly and remain consistently visible.\n- Turn on Godot’s visible collision shapes or use a debug shader to ensure Area2D shapes correctly match the intended attack areas.\n- Confirm that enemies are only damaged when visually intersecting attack visuals, not at unexpected offsets.",
        "priority": "low",
        "dependencies": [
          "20",
          "21",
          "22",
          "23"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break Task 26 into ~3 subtasks: (1) audit each weapon scene to ensure Area2D/CollisionShape2D nodes exist with correct layers/masks and sizes, (2) add and configure placeholder visuals (ColorRect/Sprite2D, modulate colors, minimal animations) for each weapon type and ensure they are decoupled from gameplay scripts, and (3) run a combined debug arena scene with all weapons to visually verify hit areas, collisions, and clarity using visible collision shapes or debug tooling."
      },
      {
        "id": "27",
        "title": "Art integration checkpoint: sprite preview scene and weapon VFX validation",
        "description": "Create a reusable sprite preview scene for quick visual checks and use it to validate delivered weapon effect art (if available), without blocking weapon code progress.",
        "details": "Implementation details:\n- Only perform this task once core weapon code is functional and art assets are available; otherwise keep placeholders as per PRD.\n- Sprite preview scene:\n  - Path: `scenes/debug/sprite_preview.tscn`.\n  - Root: `Node2D` or `Control` with a `Camera2D` configured for a 640×360 viewport at game scale.\n  - Background: simple grass tileset or solid color (placeholder or purchased tileset), implemented using `TileMap` or a full-screen Sprite2D.\n  - Add multiple sprite slots:\n    - Node group or named positions for 16x16, 32x32, 64x64 sprites.\n    - For each size, add a `Sprite2D` or `AnimatedSprite2D` that can have its `texture`/`sprite_frames` updated in the editor.\n- Expose a small editor script or tool script that allows quickly assigning a texture or animation to a slot for preview.\n- Use the scene to verify each weapon VFX sprite/animation when Ericka delivers them:\n  - Feather projectile (16x16): visibility and direction clarity when rotated.\n  - Peck hit effect (32x32): reads as directional thrust.\n  - Wing Slap circle (64x64): expanding motion visible, does not obscure player.\n  - Ice Shard (16x16): blue recolor distinct from Feather.\n  - Flame Wing (64x64): orange recolor distinct from Wing Slap.\n  - Animation speeds feel responsive.\n- Coordinate a short in-team review session (10 minutes) to show all effects to Ericka and collect notes.\n- Do not modify weapon gameplay logic during this checkpoint; only visuals and asset assignments.\n",
        "testStrategy": "Art validation tests:\n- Load `sprite_preview.tscn` in the editor and assign each delivered weapon effect sprite/animation to the appropriate slot.\n- For each asset, verify visually in the running preview scene that:\n  - The sprite is clearly visible against the grass background.\n  - The recolors (Ice vs Feather, Flame Wing vs Wing Slap) are immediately distinguishable.\n  - Animations loop at a speed that matches desired responsiveness.\n- If issues are found, document them with screenshots and descriptions, then revert to placeholder assets in gameplay scenes while waiting for art iteration, ensuring no code tasks are blocked.",
        "priority": "low",
        "dependencies": [
          "26"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break Task 27 into ~3 subtasks: (1) create the reusable sprite_preview.tscn scene with camera, background, and sized sprite slots plus any simple editor tool script, (2) wire the scene so artists/designers can quickly assign and preview weapon-related sprites/animations, and (3) perform a review pass loading each delivered VFX asset, documenting any issues, and keeping gameplay scenes on placeholders when necessary."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-10T05:29:39.120Z",
      "taskCount": 27,
      "completedCount": 16,
      "tags": [
        "master"
      ]
    }
  }
}