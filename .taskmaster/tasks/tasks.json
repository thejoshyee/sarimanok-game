{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Review existing Godot project structure and scenes",
        "description": "Analyze the current Godot 4 project under /Users/joshyee/Desktop/game-dev/sarimanok-game to understand existing scenes, scripts, and autoloads.",
        "details": "Inspect the Godot project (project.godot), scene tree, and folder layout to identify what is already implemented for player, enemies, UI, and systems such as saving or audio. Document key scenes (e.g., main scene, gameplay scene, menus), singletons, and any existing architecture decisions (naming conventions, node types, input mapping). Summarize which major MVP features appear to be fully implemented, partially implemented, or not present at all so subsequent tasks do not duplicate work.",
        "testStrategy": "Open the project in Godot 4, run the current main scene, and verify it starts without errors. Cross-check observed behavior against a short checklist of MVP features (movement, enemies, XP, gold, UI, etc.) and ensure notes are written up clearly for the rest of the team.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Open project and identify Godot version, main scene, and autoloads",
            "description": "Launch the Godot 4 project located at /Users/joshyee/Desktop/game-dev/sarimanok-game. Check the project.godot file to confirm the Godot version. Identify the main scene entry point (usually main.tscn or similar) and list all autoloads (singletons) defined in the project settings. Document these details for reference.",
            "dependencies": [],
            "details": "This step ensures the correct environment and entry point are understood before deeper exploration. Autoloads are critical for global state and cross-scene communication in Godot projects [6][7].",
            "status": "pending",
            "testStrategy": "Open the project in Godot 4, verify the version, locate the main scene, and check project settings for autoloads."
          },
          {
            "id": 2,
            "title": "Map filesystem and folder layout",
            "description": "Review the project's folder structure, focusing on directories for players, enemies, UI, and systems (such as saving, audio, input). Document the organization and naming conventions used for these folders and their contents.",
            "dependencies": [
              1
            ],
            "details": "A well-organized filesystem helps locate assets and scripts quickly. Common patterns include grouping by entity type (players, enemies) and system (UI, audio) [2][3][4].",
            "status": "pending",
            "testStrategy": "Navigate the project directory and note the structure, taking screenshots or writing a brief outline of the layout."
          },
          {
            "id": 3,
            "title": "Catalog key scenes and their responsibilities",
            "description": "List and describe the main scenes in the project (e.g., main, gameplay, menus, HUD). For each, note its purpose, root node type, and any notable scripts or child scenes. Summarize the scene tree and responsibilities for each major scene.",
            "dependencies": [
              1,
              2
            ],
            "details": "Scene organization is central to Godot's architecture. Each scene should have a clear responsibility and be modular for reuse [1][6].",
            "status": "pending",
            "testStrategy": "Open each key scene in the editor, inspect the scene tree, and document the main components and their roles."
          },
          {
            "id": 4,
            "title": "Identify existing systems for saving, audio, input mapping, and cross-cutting concerns",
            "description": "Locate and document any implemented systems for saving, audio management, input mapping, and other cross-cutting concerns. Note the architecture patterns used (e.g., autoloads, managers, data-driven resources) and how they are integrated into scenes.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "These systems are often implemented as autoloads or manager scripts and are essential for game-wide functionality [1][2][6].",
            "status": "pending",
            "testStrategy": "Search for scripts and nodes related to saving, audio, and input. Run the game and verify these systems function as expected."
          },
          {
            "id": 5,
            "title": "Summarize MVP feature coverage and share findings",
            "description": "Compile a summary of which major MVP features are fully implemented, partially implemented, or missing. Share this summary with the team in a short document, highlighting key scenes, systems, and any architectural decisions observed.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "This summary prevents duplication of work and aligns the team on the current state of the project [1][2][3].",
            "status": "pending",
            "testStrategy": "Cross-check observed features against the MVP checklist and write a concise report for the team."
          }
        ]
      },
      {
        "id": 2,
        "title": "Map PRD features to existing implementation",
        "description": "Create a feature matrix comparing the PRD’s MVP features to what the current codebase already supports.",
        "details": "Using the PRD as a source, list all core features (characters, enemies, weapons, passives, level-up system, pickups, shop, timer/win condition, endless mode, score, UI screens, save system). For each feature, note: implemented, partially implemented, or missing; where it lives in the project (scene/script paths); and any deviations from the PRD (e.g., different stats, different unlock conditions). Identify any technical foundations already present (e.g., object pooling, data-driven resources, enemy spawn manager) that should be reused.",
        "testStrategy": "Manually verify at least one example in the project for each feature category (e.g., confirm an enemy scene exists and spawns in-game, confirm some form of save data is written to disk) and update the matrix accordingly. Ensure all entries are grounded in observed behavior, not assumptions from the PRD alone.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Confirm and document technology stack and patterns",
        "description": "Clarify which technology choices and coding patterns the project currently uses so new work aligns with them.",
        "details": "Identify the Godot version in project.godot, scripting language(s) in use (GDScript only or any C#), and any third-party addons or plugins. Document architectural patterns already adopted, such as the use of autoload singletons for GameState, object pooling patterns, spatial partitioning, data-driven Resources (e.g., WeaponData, enemy configs), and how scenes are organized for menus and gameplay. Note any custom utility modules (e.g., audio manager, input manager) so new systems can integrate instead of duplicating functionality.",
        "testStrategy": "Search the project for common singleton or manager scripts (e.g., GameState, AudioManager), open them to confirm their responsibilities, and verify in the running game that they function as expected (e.g., audio volume responds to settings). Record findings in a brief architecture overview document in the repo (e.g., docs/architecture.md).",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Align player and character select features with codebase",
        "description": "Implement or complete the Sarimanok character variants and character select flow according to the PRD, reusing existing movement/combat code.",
        "details": "Based on the current player implementation, add or adjust three Sarimanok variants (Classic, Shadow, Golden) with the correct HP, speed, and damage multipliers, following existing stats conventions. Ensure the character select screen fits the current UI framework and unlock logic is wired into the save/achievement or GameState system as implemented in the project. Maintain existing animation and movement patterns (e.g., CharacterBody2D, 2-frame animations, sprite flipping, i-frames) rather than reintroducing alternative patterns.",
        "testStrategy": "From a clean profile, run the game and verify Classic is selectable and plays correctly; confirm Shadow is locked and then unlocks after surviving 15:00 in Story Mode; confirm Golden unlocks after a successful 30:00 run. Check that movement speed and HP feel consistent with the project’s units and that no runtime or console errors are produced.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate enemy roster and spawn system with existing managers",
        "description": "Implement or reconcile the four-enemy roster and spawn behavior with the project’s current enemy and spawn systems.",
        "details": "Review the existing enemy scenes and spawn manager scripts to see which enemies and behaviors are already present. Add or adjust Green Duwende, Red Duwende, Santelmo, and Manananggal boss to match the PRD’s behavior and stats while fitting the existing Area2D/physics and pooling approach. Ensure the time-based spawn timeline and stat scaling (HP/damage, spawn interval) are integrated into the current spawn manager architecture rather than creating a parallel system.",
        "testStrategy": "Run test sessions and log enemy counts and types over time. Verify that from 0:00 to 30:00 the correct enemies spawn at expected times and rates, that Manananggal appears at 20:00, and that performance remains acceptable with large numbers of enemies. Confirm drops (XP and Gold) hook into the existing pickup and progression systems without errors.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Finalize weapon and passive systems using data-driven resources",
        "description": "Ensure weapons and passives match the PRD and leverage any existing data-driven WeaponData or similar resource patterns in the project.",
        "details": "Inspect current weapon and passive implementations to see whether a Resource-based configuration system is already present. Extend or refactor as needed so Peck, Wing Slap, Feather Shot, Spiral Feathers, Ice Shard, Flame Wing, and all four passives are defined via data resources that the existing weapon manager can consume. Align upgrade levels, damage, cooldown, and debuff behaviors with the PRD while preserving current naming, folder structure, and script style.",
        "testStrategy": "Using a debug or test mode, quickly level a player to confirm all weapons and passives can be acquired and upgraded to their maximum level, and that debuff effects (e.g., slow from Ice Shard) are applied correctly. Check that no duplicate code paths for weapons exist and that all weapon definitions are loaded from the intended resource locations without runtime errors.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Validate level-up, pickup, shop, and save systems against PRD",
        "description": "Cross-check and adjust the existing progression-related systems to align with the PRD while respecting current implementations.",
        "details": "Review current XP/level-up UI and logic, pickup behavior, shop implementation, and save/load code. Compare these to the PRD’s XP curve, level-up choice rules, pickup magnet behavior, shop upgrade effects, and save data schema. Make targeted changes so behavior matches the design while preserving any established serialization formats, UI layouts, or data migration logic already in the project.",
        "testStrategy": "Perform runs that exercise: leveling multiple times, acquiring and upgrading weapons and passives, earning and spending gold in the shop, and exiting/relaunching the game to confirm persistence of gold, shop upgrades, unlocks, high scores, and settings. Validate that the XP curve and choice logic behave as expected without corrupting existing save files.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Ensure timer, win/lose conditions, modes, and scoring fit existing flow",
        "description": "Hook up or adjust game timer, Story/Endless mode behavior, win/lose conditions, and scoring within the project’s current state and scene flow management.",
        "details": "Examine how the game currently tracks time, transitions between gameplay and result screens, and distinguishes between different game modes. Align these with the PRD: Story Mode victory at 30:00 with dawn transition, Endless Mode unlocked after Story clear and with no win cap, and scoring rules based on kills and win bonus. Integrate mode selection into the existing main menu screen and result screens, reusing their current scene and navigation patterns.",
        "testStrategy": "Play separate runs in Story and Endless modes, verifying time display, correct triggering of victory and defeat flows, correct unlocking of Endless, accurate score computation and high score tracking per mode, and correct navigation back to menu or shop. Check for consistency in UI text and absence of runtime errors during scene changes.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Align UI screens and settings with current UI framework",
        "description": "Audit and complete the set of UI screens and settings described in the PRD using the project’s existing UI scenes, themes, and navigation patterns.",
        "details": "Review current implementations of the main menu, shop, settings, gameplay HUD, pause, level-up, victory/defeat, and any loading or tutorial screens. Identify missing elements (e.g., Endless button lock state, gold/high score display, weapon HUD, volume controls) and implement them in a way that matches the existing UI style, control scheme, and localization approach (e.g., use existing translation hooks or fonts). Avoid introducing a second UI framework or theme system.",
        "testStrategy": "Navigate through all screens using both keyboard and controller if supported, verifying that every screen described in the PRD exists, is reachable, and behaves correctly. Confirm that settings persist across sessions, that UI responds to different input devices as currently supported, and that no visual or layout regressions appear on the project’s target resolution.",
        "priority": "low",
        "dependencies": [
          2,
          3,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Refine performance, pooling, and code quality within existing architecture",
        "description": "Optimize and clean up performance-sensitive systems and shared code paths while preserving the project’s chosen patterns and structure.",
        "details": "Identify performance-critical areas such as enemy spawning and movement, projectiles, pickups, and particle effects. If object pooling or spatial partitioning systems already exist, extend and tune them rather than replacing them. Address any redundant or dead code revealed during the earlier feature-mapping work, and standardize patterns for managers, autoloads, and utility modules according to what the project already uses. Capture remaining technical debt or refactor candidates in a short backlog for post-MVP improvements.",
        "testStrategy": "Profile long runs (approaching or exceeding 30 minutes) on target hardware to measure frame rate, CPU/GPU usage, and memory behavior with high enemy counts. Confirm that any pooling or optimization changes do not break gameplay behavior and that no new errors or leaks are introduced. Run existing automated checks or linting configured in the project, if any, to ensure compliance with existing code quality standards.",
        "priority": "low",
        "dependencies": [
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-04T21:34:29.984Z",
      "updated": "2025-12-04T21:34:29.984Z",
      "description": "Tasks for master context"
    }
  }
}