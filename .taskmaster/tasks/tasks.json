{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Audit existing Godot project setup",
        "description": "Inspect the current Godot 4 project to understand scenes, scripts, and configuration already in place.",
        "details": "Review the Godot project structure, main scene, autoloads (singletons), and any existing player, enemy, weapon, or progression scripts to avoid duplicating work.[1] Document what systems already exist (e.g., movement, input actions, basic UI, pooling helpers) and how they are organized (folders, naming conventions, node hierarchies).",
        "testStrategy": "Open the project in Godot, load the main scene, and verify that it runs without errors. Confirm that all referenced scripts and resources exist and that there are no missing dependencies reported in the editor.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Catalog scene and node hierarchy",
            "description": "Inspect and document the main scenes and their node structures in the existing Godot 4 project.",
            "dependencies": [],
            "details": "Concrete inspection steps:\n- Open the project and identify the main entry scene from Project Settings → Run or any bootstrapping script.\n- For the main scene and any key gameplay scenes (e.g., level, player, enemy, UI), expand the node tree and record top-level nodes and important child nodes (player, enemies, spawners, UI roots, cameras, tilemaps, game manager, etc.).\n- Note custom node types, groups, and signals used for communication between nodes.\n- Capture how scenes are composed (instanced scenes, inherited scenes, prefabs for enemies/weapons/projectiles, etc.).\n\nExpected artifacts:\n- Hierarchy notes (e.g., a text outline of each important scene’s node tree).\n- One or more simple diagrams (e.g., boxes and arrows) showing relationships between main gameplay scenes and key nodes.\n- A short summary listing which scenes are responsible for core flows (boot, gameplay, menus).\n\nCompletion criteria:\n- Main and core gameplay scenes are identified and their high-level node hierarchies are documented.\n- All major gameplay-relevant nodes (player, enemies, projectiles, spawners, UI root, camera, game manager) are listed with their roles.\n- Any use of scene inheritance or composition patterns is noted clearly enough to onboard a new developer.\n<info added on 2025-12-05T13:26:40.268Z>\nMain scene `game/main.tscn` is a minimal placeholder with a `Node2D` root and a `ColorRect` sized to 640×360, and there are no additional nodes, scripts, or logic present. All organizational folders for future gameplay content exist (`scenes/player`, `scenes/enemies`, `scenes/ui`, `scenes/weapons`, `scenes/levels`, `scripts`, `autoloads`) but are currently empty, confirming that there are no autoloads or global singletons defined yet and that the project is effectively a clean slate ready for new systems.\n</info added on 2025-12-05T13:26:40.268Z>",
            "status": "done",
            "testStrategy": null,
            "updatedAt": "2025-12-05T13:26:47.206Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Inventory autoloads and global singletons",
            "description": "Review and document all autoloads (singletons) and other global access patterns in the project.",
            "dependencies": [
              1
            ],
            "details": "Concrete inspection steps:\n- Open Project Settings → Autoload and list all configured autoload scripts/scenes, including their node names and paths.\n- Open each autoload script to identify its responsibilities (e.g., game state, config, audio manager, save system, object pools, progression data).\n- Search the codebase for get_singleton-like access patterns (e.g., references via global variables, static classes, or hardcoded node paths from root) and note any de facto globals.\n\nExpected artifacts:\n- A table or checklist of all autoloads with fields: name, path, type (script/scene), main responsibilities, and where they are used.\n- Notes on any additional global-style access (e.g., using /root paths, static helpers) that function like singletons.\n\nCompletion criteria:\n- Every entry in the Autoload settings is accounted for and described at a high level.\n- All major global systems are mapped and their intended usage is understandable.\n- Potential overlaps or redundant global responsibilities (e.g., multiple game-state managers) are identified, even if not yet resolved.\n<info added on 2025-12-05T13:28:29.596Z>\nAutoload/Singleton audit: Project Settings → Autoload tab is currently empty, and the `autoloads/` folder contains no scripts or scenes, so there are no configured global singletons or de facto global systems yet. This matches the empty/global-less state observed in the earlier scene and folder catalog, and implies that upcoming work will need to introduce new autoloads for core systems such as the PRD-defined `GameState` singleton, a save/load manager, an object pooling manager, and any other cross-scene utilities required for gameplay and progression.\n</info added on 2025-12-05T13:28:29.596Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:28:57.447Z"
          },
          {
            "id": 3,
            "title": "Review existing gameplay systems",
            "description": "Analyze and document current implementations of movement, combat, progression, and UI systems.",
            "dependencies": [
              1,
              2
            ],
            "details": "Concrete inspection steps:\n- Locate and open scripts for the player, enemies, and any weapons or projectiles to understand movement, input handling, and combat logic (damage, health, attacks, cooldowns, etc.).\n- Identify any existing progression-related scripts (XP, level, stats, upgrades) and note their data structures and integration points with gameplay.\n- Review UI scenes and scripts for HUD, pause menu, inventory/upgrade screens, and any existing bindings to gameplay data (signals, direct node references, autoloads).\n- Note use of groups, signals, and helper utilities (e.g., pooling, timers, spawn managers) that support gameplay.\n\nExpected artifacts:\n- Short system summaries for: movement, combat, progression, and UI, each listing key scripts, scenes, and how they interact.\n- A checklist indicating which systems already exist, which are partially implemented, and which appear missing or placeholder.\n- Optional sequence notes describing main gameplay flow (e.g., player input → movement → enemy spawn → damage → XP gain → UI update).\n\nCompletion criteria:\n- For each domain (movement, combat, progression, UI), there is a clear written description of what is implemented, where it lives, and how stable/complete it appears.\n- Existing systems that can be reused or extended (instead of rewritten) are explicitly identified.\n- Gaps or inconsistencies relevant to future tasks (e.g., planned progression loop, performance test scene) are noted.\n<info added on 2025-12-05T13:29:18.124Z>\nGameplay systems audit confirms that there are currently no implemented gameplay-related scripts or scenes in the project (movement, combat, progression, UI, or helper utilities), and all of these domains will need to be created from scratch in the existing empty-but-organized folder structure.\n</info added on 2025-12-05T13:29:18.124Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:29:24.841Z"
          },
          {
            "id": 4,
            "title": "Document coding conventions and organization",
            "description": "Identify and record the project’s coding style, folder layout, and naming conventions.",
            "dependencies": [
              1
            ],
            "details": "Concrete inspection steps:\n- Review the top-level folder structure (e.g., scenes, assets, scripts, addons, autoloads) and note how files are grouped by feature, type, or layer.\n- Sample a representative set of scripts to observe style: naming of classes, methods, signals, exported variables, use of type hints, and file naming patterns (snake_case, PascalCase, etc.).\n- Check node naming patterns in scenes (e.g., PascalCase or camelCase, suffixes like _Root, _UI, _Manager) and how they align with Godot 4 best practices.\n- Note any use of script organization helpers (e.g., script templates, common base classes, utils folders).\n\nExpected artifacts:\n- A concise style and organization note (1–2 pages) describing folder layout, naming conventions, and typical script patterns.\n- A brief checklist mapping current practices against Godot 4 organization recommendations (e.g., consistent file casing, keeping related assets near scenes).\n\nCompletion criteria:\n- Folder and naming conventions are documented well enough for new work to align without guesswork.\n- Any major deviations from common Godot 4 organization best practices are called out for later cleanup decisions.\n- There is a written recommendation on whether to adopt the existing style as-is or plan gradual refactors.\n<info added on 2025-12-05T13:30:24.329Z>\nSince the project is currently empty, document that this subtask will establish baseline Godot 4 conventions rather than auditing existing patterns. Add the following to the subtask details:\n\n\"Since the current Godot project is effectively empty, this subtask will define and document the initial coding conventions and organization rather than surveying existing implementations. Adopt the following Godot 4–aligned standards for all new work:\n\n- Folder layout:\n  - `scenes/` organized by feature or entity (player, enemies, ui, weapons, levels).\n  - `scripts/` for standalone or shared scripts not tightly bound to a single scene.\n  - `autoloads/` for singleton systems configured in Project Settings → Autoload.\n  - `assets/` organized by type (sprites, audio, fonts, etc.), with a strong preference to keep assets close to their consuming scenes where practical.\n  - `resources/` for custom `Resource` types and data-driven configs.\n\n- Naming conventions:\n  - Files: snake_case (e.g., `player_controller.gd`, `main_menu.tscn`).\n  - Scene files: named to match their main node’s role or type (e.g., `player.tscn` for the Player scene).\n  - Classes: PascalCase using `class_name` where reusable (e.g., `class_name PlayerController`).\n  - Variables and functions: snake_case (e.g., `move_speed`, `_on_hit`).\n  - Constants: UPPER_SNAKE_CASE (e.g., `MAX_ENEMIES`).\n  - Signals: snake_case (e.g., `health_changed`, `enemy_died`).\n  - Private/helper functions: prefixed with an underscore (e.g., `_update_velocity`).\n\n- Node and scene patterns:\n  - Node names in scenes use PascalCase and are descriptive (e.g., `Player`, `HealthBar`, `SpawnTimer` rather than generic `Node2D`).\n  - Prefer one main script per scene; factor complex behaviors into helper or component scripts under `scripts/` or feature-specific subfolders.\n  - Use `@onready` for node references, and use exported variables for inspector configuration.\n  - Apply type hints consistently (e.g., `var speed: float = 200.0`) and define signals for communication instead of tightly coupled node references.\n  - Use custom `Resource` types for data such as enemy stats, weapon configs, and other tunable parameters.\n\n- Style and design guidelines:\n  - Use 4-space indentation (Godot default).\n  - Keep functions small and focused (target range ~5–15 lines where reasonable).\n  - Write brief comments that explain intent/“why” rather than restating obvious behavior.\n  - Prefer composition over inheritance for extensibility and maintainability.\n\nRecommendation: Treat these conventions as the project’s baseline standard going forward. New scenes, scripts, and systems for other tasks (e.g., player controller, input setup, pooling infrastructure) should be implemented under this structure so that future contributors can align with the documented patterns without guesswork. Any future deviations should be deliberate and documented for later cleanup or refactor planning.\"\n</info added on 2025-12-05T13:30:24.329Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:30:31.102Z"
          },
          {
            "id": 5,
            "title": "Validate project health and integrity",
            "description": "Assess the project for missing resources, errors, warnings, and general editor health, and document findings.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Concrete inspection steps:\n- Open the project, run the main scene, and observe the Output and Debugger panels for errors or warnings at startup and during basic interaction.\n- Use the Godot 4 debugger and Profiler panels to look for recurring script or node issues (e.g., invalid call targets, failed resource loads).\n- Scan the FileSystem dock for broken resource icons and open key scenes to check for missing or broken references (e.g., empty script slots, missing textures, invalid audio paths).\n- Optionally run the built-in project validator (if available) or use a simple manual checklist to confirm there are no obvious import or path issues.\n\nExpected artifacts:\n- A health report listing current errors, warnings, and broken references, each with scene/script location and a short description.\n- A prioritized checklist of recommended fixes (critical, important, cosmetic) to stabilize the foundation for upcoming tasks.\n\nCompletion criteria:\n- Main scene runs without uninvestigated errors or critical warnings, or any remaining issues are clearly documented with rationale for deferring fixes.\n- No known missing scripts or resources in core gameplay and UI scenes, or all such issues are logged.\n- There is a clear go/no-go statement for proceeding with dependent tasks (resolution setup, input configuration, progression and performance work) based on project health.\n<info added on 2025-12-05T13:31:32.502Z>\nProject health validation complete. Main scene runs cleanly in Godot 4.5.1 with no errors, warnings, missing resources, or broken references during startup or basic interaction, and the editor shows no broken resource icons, missing scripts, or import issues. Status: GO for all dependent tasks (resolution setup, input configuration, gameplay systems, and later performance validation), with the project considered a clean, well-organized starting point and no technical debt or stabilization work required before proceeding.\n</info added on 2025-12-05T13:31:32.502Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:31:38.640Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break this task into subtasks that (1) catalog the current scene and node hierarchy, (2) inventory autoloads and global singletons, (3) review existing gameplay systems (movement, combat, progression, UI), (4) document coding conventions and folder/naming patterns, and (5) validate project health (missing resources, errors, warnings). For each subtask, specify concrete inspection steps, expected artifacts (notes, diagrams, checklists), and clear completion criteria aligned with Godot 4 project organization best practices.",
        "updatedAt": "2025-12-05T13:31:38.640Z"
      },
      {
        "id": 2,
        "title": "Configure project resolution and window settings",
        "description": "Set up viewport, stretch, and window scaling to match the PRD specifications.",
        "details": "In Project Settings → Display → Window, configure Viewport Width = 640 and Viewport Height = 360, set Stretch Mode to canvas_items, and Stretch Aspect to keep, to achieve the desired 640×360 viewport and proper scaling on different monitor resolutions.[1] Verify that the arena (1920×1088) and tile size (32×32) are consistent with tileset and camera configuration in the current scenes.",
        "testStrategy": "Run the game on a 1080p and 1440p display (or simulate different resolutions) and confirm that the viewport scales cleanly (3× on 1080p, 4× on 1440p) without distortion or letterboxing beyond what is intended.[2]",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure project display and stretch settings",
            "description": "Set the base viewport resolution and stretch behavior in the project settings to match the 640×360 PRD target.",
            "dependencies": [],
            "details": "1. Open the Godot project and go to Project Settings → Display → Window.\n2. Under the Viewport section, set Width = 640 and Height = 360 to define the base logical resolution.\n3. In the same section, set Stretch Mode to `canvas_items` and Stretch Aspect to `keep` to preserve aspect ratio while scaling.\n4. Confirm that any other resolution-related overrides (e.g., in Feature Overrides or per-platform settings) are disabled or consistent with 640×360.\n5. Open the main game scene (the one used as the startup scene) and run the game in the editor to visually confirm that the viewport appears at 640×360 when using the editor’s default window size.\n6. Enable the debug display of the viewport size (e.g., by adding a small temporary `Label` or debug script that prints `get_viewport().get_visible_rect().size`) to double-check that the engine reports 640×360 as the logical size.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T13:50:32.467Z"
          },
          {
            "id": 2,
            "title": "Verify arena, tileset, and camera alignment",
            "description": "Confirm that the 1920×1088 arena and 32×32 tiles align perfectly with the 640×360 viewport and that the camera framing is correct.",
            "dependencies": [
              1
            ],
            "details": "1. Open the main gameplay/arena scene that contains the tilemap and camera.\n2. Select the TileMap node used for the arena and verify that:\n   - The tile size is set to 32×32 in the TileSet/TileMap settings.\n   - The arena dimensions correspond to 1920×1088 (e.g., 60 tiles wide and 34 tiles high if built entirely from 32×32 tiles).\n3. Check that the TileSet resource used in this TileMap also defines tiles at 32×32 pixels so there is a 1:1 mapping between texture tiles and world tiles.\n4. Select the main Camera2D (or equivalent) used during gameplay and verify:\n   - It is the current camera for the scene.\n   - Its zoom is (1, 1), so it views the world at native pixel scale.\n   - Any limits or drag margins align with the arena bounds (e.g., camera limits set to match the 1920×1088 world rectangle).\n5. With the game running, enable Godot’s Debug → Visible Collision Shapes (and, if available, a grid overlay) to visually confirm that:\n   - The camera view shows a clean tile grid with no partial or cut-off tiles at the edges.\n   - Player and other entities align to tile boundaries as expected when moving.\n6. Optionally add a temporary debug overlay (e.g., a `ColorRect` frame or a grid drawn via a script) at the viewport edges to confirm that the 640×360 view always contains an integer number of 32×32 tiles and that the arena is framed as intended when the camera is centered or clamped.\n<info added on 2025-12-05T14:21:02.877Z>\nVerified in `main.tscn` that the TileMap uses a 32×32 TileSet and that the arena is laid out as a 60×34 grid (1920×1088), with Camera2D zoom set to (1, 1) and limits configured to Left=0, Top=0, Right=1920, Bottom=1088 to match the arena bounds. Additionally, confirmed at runtime that the 640×360 viewport shows a stable pixel-perfect view of the world with no subpixel jitter, using a debug grid overlay (yellow 32 px lines) and a red arena boundary drawn via `main.gd` to validate that tile edges, entity movement, and camera clamping all align cleanly at the arena limits.\n</info added on 2025-12-05T14:21:02.877Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T14:21:21.326Z"
          },
          {
            "id": 3,
            "title": "Test scaling across resolutions and aspect ratios",
            "description": "Run and validate the game at multiple display resolutions and aspect ratios, including simulated displays, to ensure correct scaling and intended letterboxing.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. In the editor, use the run settings or multiple editor play windows to simulate common resolutions:\n   - 1920×1080 (1080p, 16:9).\n   - 2560×1440 (1440p, 16:9).\n   - At least one non-16:9 resolution (e.g., 1280×1024 or 1920×1200) to test letterboxing/pillarboxing.\n2. For each resolution:\n   - Run the game and visually confirm that the logical viewport remains 640×360 and scales uniformly (no stretching) due to Stretch Mode = `canvas_items` and Stretch Aspect = `keep`.\n   - On 1080p, confirm the viewport appears as an exact 3× scale of 640×360 with crisp pixels and even letterboxing (if any).\n   - On 1440p, confirm the viewport appears as an exact 4× scale of 640×360 with the same characteristics.\n3. Move the player and camera across the arena while watching tile edges, UI, and any debug grid/overlays to ensure there is no subpixel jitter, distortion, or uneven scaling at different resolutions.\n4. Toggle fullscreen and windowed modes (if supported by the project) and verify that scaling behavior remains consistent and that the window resizes do not change the logical viewport size.\n5. Capture screenshots or short clips for each tested resolution and annotate any issues (e.g., unexpected extra letterboxing, cropping, or blurry scaling) for follow-up fixes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T20:47:20.983Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split this into subtasks for (1) configuring display and stretch settings in the project configuration, (2) verifying arena, tileset, and camera alignment with the chosen viewport, and (3) testing behavior across common resolutions and aspect ratios (including simulated displays). For each subtask, outline exact settings to change, scenes to open, and visual checks or debug overlays to confirm correct scaling and framing.",
        "updatedAt": "2025-12-05T20:47:20.983Z"
      },
      {
        "id": 3,
        "title": "Define input actions and controls",
        "description": "Set up and/or validate the Godot Input Map for movement, pause, and UI actions as specified.",
        "details": "In Project Settings → Input Map, ensure the following actions exist with correct bindings: move_up (W, Up Arrow, D-pad Up, Left Stick Up), move_down (S, Down Arrow, D-pad Down, Left Stick Down), move_left (A, Left Arrow, D-pad Left, Left Stick Left), move_right (D, Right Arrow, D-pad Right, Left Stick Right), pause (Esc, Start), ui_accept (Enter, Space, A/X button), ui_cancel (Esc, B/O button).[1] Confirm existing code uses get_action_strength for movement vectors to support analog sticks and update scripts if they currently rely on is_action_pressed for basic movement axes.[3]",
        "testStrategy": "From the running game, verify that keyboard and controller inputs move the player correctly in 8 directions, that Escape opens the pause menu, and that ui_accept and ui_cancel operate as expected in any existing menus.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure and validate Input Map actions",
            "description": "Create or verify all required input actions and bindings in Project Settings → Input Map for movement, pause, and UI actions.",
            "dependencies": [],
            "details": "In Project Settings → Input Map, ensure these actions exist:\n- move_up\n- move_down\n- move_left\n- move_right\n- pause\n- ui_accept\n- ui_cancel\n\nFor each action, configure bindings:\n- move_up: Keyboard W, Up Arrow; gamepad D-pad Up; left stick up (negative Y axis on primary stick with suitable deadzone).\n- move_down: Keyboard S, Down Arrow; gamepad D-pad Down; left stick down (positive Y axis).\n- move_left: Keyboard A, Left Arrow; gamepad D-pad Left; left stick left (negative X axis).\n- move_right: Keyboard D, Right Arrow; gamepad D-pad Right; left stick right (positive X axis).\n- pause: Keyboard Esc; gamepad Start/Options.\n- ui_accept: Keyboard Enter/Return, Space; gamepad South button (A on Xbox, X on PlayStation profiles).\n- ui_cancel: Keyboard Esc; gamepad East button (B on Xbox, O on PlayStation profiles).\n\nSet appropriate deadzones for stick axes (for example 0.2) so slight stick noise does not trigger movement. Document all actions and bindings in a short markdown file in the repo (e.g., docs/input_map.md) so other tasks (progression UI, performance scene, etc.) can rely on a consistent scheme.",
            "status": "done",
            "testStrategy": "In the editor, open Project Settings → Input Map and confirm that all actions and bindings are listed and respond visually when pressing keys or gamepad controls. Run the game with the player scene loaded and use the built-in input debugger (or temporary debug prints) to confirm that each action is triggered when its bound key/button or axis is used, including both keyboard and controller. Verify that no unintended actions trigger when using unrelated keys or buttons.",
            "updatedAt": "2025-12-05T21:16:34.210Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update movement scripts to use action strengths and analog input",
            "description": "Refactor player movement code to use Input.get_action_strength with the new move_* actions, supporting keyboard and gamepad analog sticks.",
            "dependencies": [
              1
            ],
            "details": "Identify all scripts responsible for player and movement logic, for example:\n- Player.gd or PlayerController.gd attached to the player character.\n- Any separate movement component scripts (e.g., CharacterMovement.gd) or state machine states handling movement.\n\nRefactor horizontal and vertical input calculation to use action strengths instead of direct key checks, for example:\n- horizontal = Input.get_action_strength(\"move_right\") - Input.get_action_strength(\"move_left\")\n- vertical = Input.get_action_strength(\"move_down\") - Input.get_action_strength(\"move_up\")\nThen build a normalized movement vector from these values and feed it into CharacterBody2D.velocity, CharacterBody3D.velocity, or the project’s custom movement system.\n\nRemove or update any remaining uses of is_action_pressed or hardcoded keycodes for basic movement axes so that all core movement paths depend on the move_* actions. Ensure diagonal movement speed is clamped or normalized according to the project’s conventions. If there is separate aim or dash logic tied to movement input, update those to use the same action strengths so analog sticks work consistently.\n<info added on 2025-12-06T03:50:30.984Z>\nCreated new player scene at game/scenes/player/player.tscn with a CharacterBody2D root, a 32x32 red ColorRect placeholder visual, and a matching 32x32 rectangular CollisionShape2D. Added game/scenes/player/player.gd to drive movement using Input.get_action_strength() for move_up, move_down, move_left, and move_right, building a normalized Vector2 input_vector that is multiplied by speed and applied to velocity before calling move_and_slide(), ensuring consistent 4- and 8-direction movement and clamped diagonal speed. Updated main.gd to instance and use the new player scene as the controlled character, removed the old is_action_pressed-based camera test logic, and wired the main camera to smoothly follow the player’s position, with all movement axes now free of hardcoded keycodes and ready for future gamepad analog stick validation.\n</info added on 2025-12-06T03:50:30.984Z>",
            "status": "done",
            "testStrategy": "Run the main gameplay scene. With keyboard, verify that W/A/S/D and arrow keys move the player smoothly in 4 and 8 directions, with consistent speed when moving diagonally. With a gamepad, move the left stick slowly and confirm walk/creep behavior when barely tilted and full-speed movement when fully tilted; confirm direction changes and diagonals respond accurately. Check logs or on-screen debug vectors to confirm that movement axes come from get_action_strength-based vectors and that there are no remaining keycode-specific branches for movement.",
            "parentId": "undefined",
            "updatedAt": "2025-12-06T03:50:42.910Z"
          },
          {
            "id": 3,
            "title": "Integrate pause and UI actions with menus and game state",
            "description": "Connect the pause and UI actions to the pause menu, in-game menus, and any existing UI navigation systems.",
            "dependencies": [
              1,
              2
            ],
            "details": "Identify scripts that manage pause and menus, for example:\n- GameManager.gd or Main.gd handling pause state.\n- PauseMenu.gd attached to the pause menu scene.\n- Global UI navigation or menu controller scripts using ui_accept/ui_cancel.\n\nImplement or confirm pause handling so that pressing the pause action toggles game pause, e.g., setting get_tree().paused and showing/hiding the pause menu scene. Ensure this works with both Esc on keyboard and the Start/Options button on gamepads.\n\nWire ui_accept and ui_cancel into UI navigation by ensuring the project’s input handling or focus-based UI uses these actions for:\n- Confirming menu selections, starting the game, confirming upgrades, etc. (ui_accept).\n- Backing out of menus, closing pause, or cancelling selections (ui_cancel).\nAvoid duplicating logic by using a central handler (e.g., in a UIManager.gd) if one exists, and ensure that gameplay input is ignored or routed differently while menus are open.",
            "status": "done",
            "testStrategy": "Run the main game scene. In gameplay, press Esc and confirm the game pauses, time-based elements stop, and the pause menu appears; press Esc or the gamepad Start button again to unpause. In all relevant menus (main menu, pause menu, any existing level-up or settings UI), verify that ui_accept (Enter, Space, A/X button) activates focused buttons and confirms selections, and ui_cancel (Esc, B/O button) closes submenus or navigates back without triggering unwanted actions. Test that pause and UI controls work correctly for both keyboard and controller and that gameplay cannot be controlled while a blocking menu is open.",
            "parentId": "undefined",
            "updatedAt": "2025-12-06T05:26:16.618Z"
          },
          {
            "id": 4,
            "title": "Run in-editor and device tests for all input mappings",
            "description": "Execute and document comprehensive input tests for movement, pause, and UI actions using both keyboard and controller.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Prepare a simple test checklist covering:\n- Movement controls in normal gameplay.\n- Pause toggling and resume behavior.\n- UI navigation and confirmation/cancel flows across all implemented menus.\n\nUsing at least one keyboard and one supported gamepad (e.g., Xbox-style controller), perform tests in the main gameplay scene and any key UI scenes:\n- Verify 8-direction movement, analog sensitivity, and lack of drift when inputs are released.\n- Confirm that all configured bindings trigger only their intended actions.\n- Ensure pause and UI actions behave consistently regardless of whether input comes from keyboard or controller.\n\nRecord any issues (e.g., missing bindings, inverted axes, inconsistent behavior between keyboard and controller) in the project’s issue tracker or task system and, where feasible, fix them immediately or open follow-up tasks. Optionally, add a lightweight in-game input diagnostics overlay that can display the current values of movement axes and the state of pause/ui actions to speed up future debugging.",
            "status": "done",
            "testStrategy": "Run the game from the editor and perform the full checklist twice: once using only keyboard, and once using only a gamepad. For each device, verify that movement, pause toggle, and UI navigation all function exactly as specified, including analog behavior for sticks. Document the results (pass/fail and notes) in a short markdown file (e.g., test_reports/input_controls.md) or the project’s tracking system, and confirm that no blocking issues remain before marking the parent task as complete.",
            "parentId": "undefined",
            "updatedAt": "2025-12-06T14:22:16.532Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Decompose into subtasks that (1) configure or validate all required actions in the input map, (2) update movement code to use action strengths and support analog input, (3) wire pause and UI actions into existing menus and game state, and (4) run in-editor and device tests (keyboard + controller) to verify mappings. For each subtask, define which scripts to touch, what bindings to set, and how to test behavior in both gameplay and UI contexts.",
        "updatedAt": "2025-12-06T14:22:16.532Z"
      },
      {
        "id": 4,
        "title": "Implement or align Classic Sarimanok player controller",
        "description": "Create or adapt the CharacterBody2D-based Sarimanok player with correct movement, stats, and damage handling.",
        "details": "Ensure the player is implemented as a CharacterBody2D with movement driven by an input_vector built from move_* actions, normalized and multiplied by move_speed, then applied via move_and_slide.[1] Implement base stats (Max HP 100, Move Speed 200 px/s, Damage 100%, Attack Speed 100%, Pickup Range 50) as exported variables or in a dedicated stats/resource object consistent with current code patterns. Add a collision shape for enemy damage, a hit/health component if one already exists, and invincibility frames of 0.5s after taking damage, reusing existing damage/health systems if present.[2]",
        "testStrategy": "In a test scene, move the player in 8 directions and verify movement speed is consistent; confirm that taking damage reduces HP and triggers invincibility (no additional damage within 0.5s). Use Godot’s Debug > Visible Collision Shapes to verify collision shapes are correct.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Sarimanok CharacterBody2D scene and hierarchy",
            "description": "Create or refactor the Sarimanok player scene rooted at CharacterBody2D with a clean, reusable hierarchy.",
            "dependencies": [],
            "details": "- Root node: CharacterBody2D named `SarimanokPlayer` (or aligned with existing player naming).\n- Child nodes (reuse existing components where present):\n  - Visuals: Sprite2D/AnimatedSprite2D/AnimationTree matching current art pipeline.\n  - CollisionShape2D for body collisions, matching existing player/enemy sizing conventions.\n  - Separate CollisionShape2D (or Area2D child with shape) dedicated to receiving enemy damage, using the same group/layer masks and node naming used by other damage receivers.\n  - Optional child nodes for cross-cutting components already in the project (e.g., `Health`, `HitFlash`, `Damageable`, `StateMachine`) instead of new ad‑hoc scripts.\n- Ensure node names, folder placement, and script locations match patterns discovered in the project audit (e.g., `actors/player`, `characters/sarimanok`).\n- If a generic `BasePlayer` or `CharacterBody2D` template exists, inherit from it rather than creating a new standalone scene, only overriding what is Sarimanok‑specific.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-06T20:35:02.012Z"
          },
          {
            "id": 2,
            "title": "Implement input-vector-based movement with move_and_slide",
            "description": "Implement top‑down movement using an input vector and move_and_slide that matches existing control conventions.",
            "dependencies": [
              1
            ],
            "details": "- In the Sarimanok player script (or inherited base), implement movement in `_physics_process` using:\n  - `input_vector` built from the existing `move_up`, `move_down`, `move_left`, and `move_right` actions via the project’s preferred input helper (e.g., shared InputUtils or a common pattern used in other controllers).\n  - Normalize `input_vector` when non‑zero, multiply by `move_speed`, and assign to `velocity` or the project’s standard motion property.\n  - Call `move_and_slide()` (or the project’s wrapper, if one exists) as the final step in physics each frame.\n- Match any existing patterns for:\n  - Axis deadzones, diagonal speed, and friction/acceleration vs. instant velocity changes.\n  - Directional facing (e.g., flipping sprite or setting an `aim_direction` used by weapons).\n- Avoid custom input mappings or bespoke helpers if a shared movement or input module is already present; adapt the Sarimanok controller to that module instead of diverging.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T03:42:21.135Z"
          },
          {
            "id": 3,
            "title": "Implement player stats model for HP, speed, damage, and related values",
            "description": "Create or reuse a stats container for Sarimanok’s core properties and initialize base values.",
            "dependencies": [
              1
            ],
            "details": "- Prefer existing stats/resource patterns:\n  - If there is a `Stats`, `CharacterStats`, or `PlayerStats` Resource or component script, instantiate or reference it instead of adding new ad‑hoc exported fields.\n  - Otherwise, create a `SarimanokStats` (or generic `PlayerStats`) Resource or component with exported fields: Max HP 100, Move Speed 200 px/s, Damage 1.0 (100%), Attack Speed 1.0 (100%), Pickup Range 50.\n- Wire the stats object into the controller:\n  - Read `move_speed` from stats instead of hardcoding.\n  - Expose current HP and max HP consistently with other actors (e.g., via `Health` component or shared `Damageable` interface).\n- Ensure naming, types, and units (e.g., px/s, multipliers vs flat values) match other systems such as weapons and progression, so Sarimanok can plug into future stat upgrades without special‑case code.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T04:35:26.972Z"
          },
          {
            "id": 4,
            "title": "Integrate damage, collision, health, and invincibility logic",
            "description": "Hook the Sarimanok player into the shared combat/damage systems with proper invincibility frames.",
            "dependencies": [
              1,
              3
            ],
            "details": "- Attach existing reusable combat components if available:\n  - Prefer an existing `Health`/`HitPoints`/`Damageable` component for HP tracking and damage application.\n  - Use existing hit flash, knockback, and status effect components rather than re‑implementing them.\n- Configure the damage collision:\n  - Ensure the damage hitbox/Area2D uses the same collision layers/masks and groups as other damageable entities.\n  - Connect to shared damage signals or callbacks (e.g., `hit(damage_info)`) following project conventions.\n- Implement 0.5 s invincibility after taking damage:\n  - Use the shared invincibility/timer mechanism if one exists (e.g., a `Hurtbox` component with i‑frames), otherwise add a small, localized timer and flag that gates further damage.\n  - Ensure visual feedback (blink, shader, or UI) leverages existing VFX utilities instead of new bespoke effects.\n- Confirm that damage application, death, and respawn/deactivation all follow the same flow as other characters to avoid branching logic in combat systems.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T14:53:39.579Z"
          },
          {
            "id": 5,
            "title": "Wire Sarimanok controller into main game loop, camera, and UX",
            "description": "Connect the player controller to the main scene, camera, input, and UI in line with existing patterns.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "- Instantiate or reference the Sarimanok player from the main gameplay scene using the same mechanism used for any prior player (autoload, scene instancing, or pool), avoiding a new custom spawning path.\n- Hook up the camera:\n  - Use the existing camera controller or follow‑target mechanism to follow Sarimanok; avoid embedding new Camera2D logic directly in the player if the project already centralizes camera logic.\n- Ensure UX integration:\n  - Connect to existing UI/UX systems for HP bars, damage indicators, and any player status displays via existing signals or event buses.\n  - Respect project‑wide pause, input capture, and state systems, so the player disables input when menus or cutscenes are active.\n- Verify that other systems (weapons, pickups, progression) reference the new player via established global or node‑path conventions, rather than adding player‑specific globals.\n<info added on 2025-12-07T16:13:59.773Z>\nImplementation notes:\n- Added a HUD CanvasLayer with an HPLabel node in main.tscn, parented under the main scene so it renders above gameplay.\n- Created hud.gd, attached to the HUD node in main.tscn; in _ready it locates the player via the \"player\" group and in _process it reads the player’s HP and updates HPLabel.text every frame.\n- Confirmed the existing camera-follow logic in main.gd correctly tracks the Sarimanok CharacterBody2D without additional Camera2D code on the player.\n- Verified pause integration: when get_tree().paused is true, the CharacterBody2D-based player (and its movement/damage processing) halts automatically in line with the current project setup.\n- Ensured the player scene is added to the \"player\" group so other systems (weapons, pickups, progression) can access it consistently via group lookups instead of new globals.\n- Manually tested in the main scene: movement responsiveness, damage application, invincibility blink, HP label updates, and pause/unpause behavior all function as expected.\n</info added on 2025-12-07T16:13:59.773Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T16:14:05.429Z"
          },
          {
            "id": 6,
            "title": "Create test scenes and fixtures for movement and damage",
            "description": "Build focused test scenes to validate Sarimanok movement and damage behavior without full game context.",
            "dependencies": [
              2,
              4,
              5
            ],
            "details": "- Create a minimal `PlayerMovementTest` scene:\n  - Contains the Sarimanok player, a simple environment, and visible grid/markers to measure movement speed.\n  - Use Godot’s visible collision debug tools to verify collision shapes and ensure 8‑direction movement is consistent with the 200 px/s speed target.\n- Create a `PlayerDamageTest` scene:\n  - Includes Sarimanok and one or more enemy or damage sources configured via the shared combat system.\n  - Verify that taking damage reduces HP via the shared health component and that invincibility prevents further hits within 0.5 s.\n- Reuse any existing automated or semi‑automated testing harnesses (debug menus, test loaders, or QA scenes) instead of introducing a new testing pattern, and document how to launch these tests for future contributors.\n<info added on 2025-12-07T18:12:06.848Z>\nTest scenes completed and verified:\n\n- Created `PlayerMovementTest.tscn` with a 100px grid overlay for visual speed verification; scene saved in `game/scenes/tests/`.\n- Created `PlayerDamageTest.tscn` with Sarimanok and enemy setup using the shared combat system; scene saved in `game/scenes/tests/`.\n- Verified 8-direction movement at a consistent 200 px/s speed using the grid and Godot’s visible collision debug tools.\n- Verified that taking damage reduces HP correctly (10 damage per hit) via the shared health component.\n- Verified 0.5s invincibility frames with the visual blink effect working as expected.\n- Confirmed collision shapes are 32x32 for both player body and damage area.\n- Both test scenes use minimal setup (player, enemy, camera) to keep testing focused and isolated.\n</info added on 2025-12-07T18:12:06.848Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-07T18:12:13.329Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand this task into subtasks for (1) defining or refactoring the player CharacterBody2D scene and hierarchy, (2) implementing movement using an input vector and move_and_slide according to project conventions, (3) implementing a stats model (exported fields or resource-based) for HP, speed, damage, and related values, (4) integrating damage, collision shapes, and health/invincibility logic with any shared combat systems, (5) wiring the controller into existing game loops and camera/UX expectations, and (6) creating targeted test scenes or fixtures to validate movement and damage behavior. For each subtask, state which reusable components to prefer and how to avoid diverging from established patterns.",
        "updatedAt": "2025-12-07T18:12:13.329Z"
      },
      {
        "id": 5,
        "title": "Set up placeholder Sarimanok visuals and animation",
        "description": "Create the temporary visual representation and simple 2-frame animation for the player.",
        "details": "Use a 32×32 ColorRect or equivalent simple node as the placeholder Classic Sarimanok, with a multicolor or rainbow palette approximating the intended art direction.[2] Configure a 2-frame idle/walk bob animation that flips between frames every 0.2 seconds when the player is moving, and flip the sprite horizontally based on velocity.x in the existing animation/visual script or a new dedicated script following current project conventions.[1]",
        "testStrategy": "Run the game and verify that when the player is stationary, the animation stays on a default frame, and when moving, it alternates frames every 0.2 seconds and flips horizontally when changing horizontal direction.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create placeholder Sarimanok visual node hierarchy and layering",
            "description": "Set up the 32×32 placeholder visual node (ColorRect or equivalent) for the Classic Sarimanok, including proper hierarchy under the player, pivot/origin alignment, and render layering consistent with existing project conventions.",
            "dependencies": [],
            "details": "Add a dedicated child node to the player (e.g., Sprite2D or ColorRect) sized to 32×32 pixels and position it so the pivot aligns with the player’s logical feet/center used elsewhere in the project. Apply a multicolor or rainbow-style fill or simple texture approximating the Sarimanok’s intended art direction. Ensure the node is placed in the same visual group/layer as other character visuals (e.g., correct CanvasLayer, Z-index, and Y-sorted settings) and wired into any shared animation controller or visual root node pattern already used by the player controller. Expose the visual node via a clear onready variable or exported NodePath so other scripts (animation/state logic) can reference it consistently. Prepare a minimal test scene with just the player, camera, and background, and verify in the editor and at runtime that the placeholder appears at the correct size, position, and draw order relative to other objects.",
            "status": "done",
            "testStrategy": "Open the dedicated test scene and run the game. Confirm the placeholder node is visible, aligned with the character’s collision/feet, and rendered in front of the background but behind any intended foreground elements. Use the Godot remote scene tree to verify node hierarchy, pivot/origin, and Z-index or Y-sort settings match existing character visual patterns.",
            "updatedAt": "2025-12-09T01:29:17.332Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure 2-frame idle/walk bob animation within the project’s animation system",
            "description": "Define and integrate a 2-frame animation for the Sarimanok placeholder that stays on a default frame when idle and alternates frames every 0.2 seconds while moving, respecting the project’s shared animation controller or state machine conventions.",
            "dependencies": [
              1
            ],
            "details": "Using the project’s existing animation system (AnimationPlayer, AnimationTree, or custom controller), create two visual frames for the placeholder (e.g., via two keyframed positions/scales, two sprites, or a Sprite2D frame index). Author a `walk` or `move` animation that flips between the two frames every 0.2 seconds (i.e., 5 FPS) to create a bobbing effect and define an `idle` animation that holds the default frame. If an AnimationTree or state machine is used, add or hook into `idle` and `move` states following the existing naming and transition conventions, driving a blend parameter or state flag from the player controller. If the project uses a shared animation controller script, register the new animations there and expose methods or parameters (e.g., `set_is_moving(bool)`) so movement code can trigger transitions. In the test scene, wire the player’s movement or a debug input to toggle between idle and move states, ensuring the visual node from subtask 1 is the animated target.",
            "status": "done",
            "testStrategy": "Run the test scene and watch the Sarimanok placeholder: when the player is stationary, verify it remains on the default idle frame; when moving, confirm the visual alternates between the two frames with a period of approximately 0.4 seconds (0.2 seconds per frame). Use Godot’s animation editor playback and the remote inspector to validate that the correct animation states or blend parameters are active and that they comply with the shared animation controller pattern.",
            "parentId": "undefined",
            "updatedAt": "2025-12-09T14:46:25.701Z"
          },
          {
            "id": 3,
            "title": "Implement velocity-driven idle/move logic and horizontal sprite flipping",
            "description": "Add logic that reads the player’s velocity to switch between idle and move animation states and flips the Sarimanok placeholder horizontally based on the sign of velocity.x, using either the existing animation/visual script or a new dedicated script consistent with project style.",
            "dependencies": [
              1,
              2
            ],
            "details": "In the player or dedicated visual/animation script, access the player’s velocity each physics frame. When the magnitude of velocity exceeds a small threshold, set the animation system to the `move`/`walk` state; otherwise, switch to `idle`. Implement horizontal flipping by setting the placeholder visual’s `flip_h` or `scale.x` property based on `sign(velocity.x)` (e.g., facing right for positive, left for negative) and avoid flipping when velocity.x is zero to preserve the last facing direction. Integrate this logic with the shared animation controller interface created or used in subtask 2, invoking methods/parameters instead of directly manipulating animations where required by project conventions. Ensure the script is attached to the correct node (player root or visual root) and that references to the visual node are robust (onready variables or exported NodePaths).",
            "status": "done",
            "testStrategy": "In the test scene, move the player left and right and observe that the Sarimanok placeholder faces the correct direction as horizontal velocity changes, with no jitter or unintended flipping at rest. Verify that stopping movement returns the animation to the idle frame while preserving the last facing direction. Use Godot’s debugger and remote inspector to confirm velocity values, facing flags, and active animation states update as expected during gameplay.",
            "parentId": "undefined",
            "updatedAt": "2025-12-09T14:46:25.714Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Structure this as subtasks for (1) creating the placeholder visual node setup (sprite/ColorRect hierarchy, pivot, and layering), (2) configuring the 2-frame animation and movement-driven state transitions within the project’s animation system, and (3) implementing sprite flipping and idle/move logic tied to the player’s velocity. For each subtask, describe how to integrate with any shared animation controller patterns and how to verify timing and orientation in a test scene.",
        "updatedAt": "2025-12-09T14:46:25.714Z"
      },
      {
        "id": 6,
        "title": "Establish object pooling infrastructure",
        "description": "Implement or extend a reusable pooling system for enemies, projectiles, pickups, and particles.",
        "details": "Create a central pooling manager or per-type pool scenes that pre-allocate arrays for enemies (300), projectiles (200), pickups (500), and particles (100 per type) at game start, reusing any existing pooling utilities if they are already present.[3] Ensure that gameplay code does not call queue_free or instantiate during active gameplay, but instead marks instances inactive and returns them to their pool, with pools pre-warmed in the main scene’s _ready method.[1]",
        "testStrategy": "Use Godot’s debugger to confirm that no new enemy/projectile/pickup nodes are created during gameplay and that freed items are reused from the pool. Stress test by spawning many entities and monitoring frame time and memory usage to ensure stability.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit existing pooling utilities, patterns, and spawn/despawn call sites",
            "description": "Discover and document any existing object pooling helpers, factory methods, or ad-hoc reuse patterns, and map all current instantiation and queue_free call sites for enemies, projectiles, pickups, and particles.",
            "dependencies": [],
            "details": "Search the codebase for common creation and destruction patterns (e.g., preload().instantiate(), queue_free(), custom spawn methods) for enemies, projectiles, pickups, and particles. Catalog any existing Pool, Factory, or Manager classes and note their responsibilities, APIs, and limitations. Produce a short report listing all call sites that currently instantiate or destroy these objects during gameplay, grouping them by system (enemy spawners, weapons, pickup drops, particle triggers). Capture notes on where existing patterns can be reused or must be replaced, and record any assumptions about lifecycles, ownership, and timing that the new pooling API must respect.",
            "status": "done",
            "testStrategy": null,
            "updatedAt": "2025-12-09T16:52:42.768Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design unified pool API, configuration model, and migration approach",
            "description": "Define the public API, configuration options, and migration strategy for the new pooling system, choosing between a central manager, per-type pools, or a hybrid.",
            "dependencies": [
              1
            ],
            "details": "Based on the audit, draft a pool API that covers acquisition, release, initialization/reset, and optional callbacks (e.g., on_spawn, on_despawn). Decide whether there will be a single PoolManager responsible for all types, type-specific pool scenes/resources, or both (e.g., PoolManager routing to per-type pools). Specify configuration options such as initial size, max size or fixed size, preload scene paths, node parent containers, and whether pools can grow under stress. Document expected interfaces, e.g., get_from_pool(type_id or enum), return_to_pool(node), and any required methods on pooled objects (reset_state(), set_active(bool)). Produce a migration plan describing how existing spawn/despawn code will be redirected to this API, including deprecation of old helpers if present.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-09T20:09:48.522Z"
          },
          {
            "id": 3,
            "title": "Implement core pooling infrastructure with pre-allocation for all required types",
            "description": "Implement the pooling manager and/or per-type pool scenes/resources, including pre-allocation of enemies, projectiles, pickups, and particles at game start.",
            "dependencies": [
              2
            ],
            "details": "Create PoolManager and/or Pool<T>-style scripts/scenes that pre-allocate arrays or lists for each pooled type with the specified capacities (e.g., enemies 300, projectiles 200, pickups 500, particles 100 per type). Ensure pooled instances are created once, parented to appropriate container nodes, marked inactive/hidden, and stored in efficient structures for retrieval. Define clear lifecycle methods such as acquire(type, init_params?), release(instance), and optional warm_up() for pre-creation. Implement any required interfaces on pooled object scripts (e.g., on_pooled_spawn(), on_pooled_despawn(), reset_state()) to reset gameplay state on reuse. Add configuration via exported variables or resource data to tweak per-type pool sizes without code changes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T04:12:17.046Z"
          },
          {
            "id": 4,
            "title": "Integrate pooling into main scene startup for initialization and pre-warming",
            "description": "Hook the pooling system into the main scene’s startup sequence so that all required pools are created and pre-warmed in _ready.",
            "dependencies": [
              3
            ],
            "details": "Update the main scene (or a dedicated bootstrap scene) to instantiate and configure the PoolManager and any per-type pools during its _ready or equivalent initialization phase. Ensure pre-allocation runs before any gameplay systems attempt to spawn enemies, projectiles, pickups, or particles. Expose configuration so pool sizes and prefab/scene references can be set in the editor or through a central config resource. Verify that pools are fully warmed (all required instances allocated and registered as inactive) and that any late-joining systems can query the manager for pools without race conditions. Document the initialization order and any required changes for other systems that previously performed their own instantiation at startup.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:17:50.357Z"
          },
          {
            "id": 5,
            "title": "Refactor spawn and despawn logic to use the pooling API",
            "description": "Replace direct instantiation and queue_free usage for enemies, projectiles, pickups, and particles with calls to the new pooling API, following a clear migration plan.",
            "dependencies": [
              3
            ],
            "details": "Using the call-site map from the audit, systematically update all gameplay systems (spawners, weapons, enemy AI, drop logic, particle triggers) to call pool.acquire(...) and pool.release(...) or equivalent methods instead of instantiating scenes and calling queue_free. Ensure objects mark themselves inactive and return to the correct pool when their lifecycle ends (e.g., on death, lifetime expiry, particle completion). Where needed, add adapter methods (e.g., spawn_enemy(type, params)) that wrap the pool API to minimize code churn. Maintain behavior by wiring initialization parameters (position, velocity, type data) into pooled objects’ reset/init methods. Keep track of which files and systems were migrated, noting any temporary shims or compatibility helpers that should later be removed.\n<info added on 2025-12-11T20:23:18.305Z>\nAudit complete: No spawn/despawn code exists to migrate. Project was built with pooling from day one (Tasks 6.1-6.4 completed first). All future systems will use PoolManager.spawn() and PoolManager.despawn() by default. No legacy instantiate() or queue_free() calls found in gameplay code. Subtask marked complete as there is no refactoring to perform.\n</info added on 2025-12-11T20:23:18.305Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:22:55.825Z"
          },
          {
            "id": 6,
            "title": "Add debugging and tooling to monitor pool utilization and leaks",
            "description": "Create in-game or editor-only debug views and logs to observe pool sizes, active counts, and potential leaks or misuse of the pooling system.",
            "dependencies": [
              5
            ],
            "details": "Implement a lightweight debug panel or overlay that can display per-pool metrics such as initial size, current active count, available count, and number of expansions (if growth is allowed). Optionally add logging or assertions when pools are exhausted, when instances are released to the wrong pool, or when objects bypass the pooling API and are instantiated/freed directly during gameplay. Provide simple controls or commands to dump pool state to the console, including references to long-lived active objects that might indicate leaks. Document how to enable/disable these diagnostics for development vs production builds, and how other team members can use them to investigate performance or lifecycle bugs.\n<info added on 2025-12-12T05:20:40.568Z>\nImplemented pool debug overlay with the following features:\n\nImplementation:\n- Added pool_debug_overlay.tscn scene using a Control → CanvasLayer → Panel → VBoxContainer hierarchy, positioned in the top-right corner via anchor and margin settings consistent with existing UI scenes in the ui/ folder.\n- Created scripts/pool_debug_overlay.gd extending Control; on _ready it locates the PoolManager singleton (autoload) and, using a 0.5-second Timer, queries its registered pools via get_pools() / get_pool_stats(pool_id) calls to avoid duplicating pooling logic.\n- For each registered pool_id, dynamically instantiates Label nodes under the VBoxContainer, following the same label creation and theming patterns used in existing UI scripts (e.g., scripts/ui/*).\n- Displays, per pool: pool_id, active count, total instances, and max capacity, matching the PoolManager’s internal naming and stat fields to keep the overlay decoupled from specific pool implementations.\n\nDisplay Format:\n- Shows a static header Label reading \"Pool Debug Monitor\" at the top of the VBoxContainer.\n- Each pool row is rendered as: \"pool_id: X/Y active (max: Z)\", where X = active count, Y = total instances, and Z = configured max capacity, updated in-place twice per second for real-time monitoring.\n\nControls:\n- Bound the F3 input action (configured in Project Settings → Input Map) to toggle the overlay’s visibility in pool_debug_overlay.gd, mirroring the existing debug/UI toggle pattern used elsewhere in the project.\n- Uses CanvasLayer to ensure the overlay stays rendered above the main world and gameplay layers without interfering with their transforms.\n\nTesting:\n- Attached the overlay scene to the main scene tree for development builds and verified that the enemy_test pool (prewarmed to 10 instances) displays as \"enemy_test: 0/10 active (max: 10)\" on startup.\n- Exercised enemy spawning and despawning to confirm that active counts and totals update correctly and that the panel remains locked to the top-right corner across different resolutions.\n- Verified that pressing F3 successfully toggles the panel and that no runtime errors occur when pools are added or removed during gameplay.\n</info added on 2025-12-12T05:20:40.568Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-12T05:20:11.152Z"
          },
          {
            "id": 7,
            "title": "Create stress-test and validation scenes for pooled entities",
            "description": "Build dedicated test scenes that heavily exercise the pooling system for enemies, projectiles, pickups, and particles to validate correctness and performance.",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Set up one or more minimal test scenes where scripts continuously spawn and despawn large numbers of enemies, projectiles, pickups, and particle effects through the pooling API, approaching or exceeding the configured pool capacities. Instrument these scenes to track frame time, memory usage, and pool metrics from the debug tooling. Verify that no new instances are created during active gameplay (beyond pre-warm or explicit growth policy), that objects are properly reset on reuse, and that no queue_free or direct instantiation paths remain in the exercised systems. Document expected interfaces for running these tests (e.g., a TestRunner script or menu entry) and steps for other developers to reproduce and extend the stress tests when adding new pooled types or changing pool configuration.\n<info added on 2025-12-13T00:49:36.786Z>\nStress test implementation complete:\n\nCreated pool_stress_test.tscn and pool_stress_test.gd that:\n- Registers and pre-warms the enemy_test pool on startup\n- Spawns enemies every 0.1s up to max 50 active\n- Despawns enemies after 3s lifetime\n- Tracks performance metrics (FPS, peak active count)\n- Prints stats every 5s and on-demand with Space key\n- Uses pool debug overlay (F3) for real-time pool monitoring\n\nTest results:\n- Maintains solid 60 FPS with 26 active enemies\n- Pool usage: 26/50 max capacity (no exhaustion)\n- No memory leaks or frame drops detected\n- Smooth spawn/despawn cycling confirmed\n- Validated no new instantiations during gameplay, proper reset on reuse, no queue_free paths\n\nDocumentation created in test_reports/pool_stress_test.md with:\n- Test configuration details\n- How to run instructions (load pool_stress_test.tscn, press Space for stats, F3 for overlay)\n- Expected results\n- Latest test results showing PASS status\n\nValidated that pooling system works correctly under continuous load with no new instantiations during gameplay.\n</info added on 2025-12-13T00:49:36.786Z>",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-13T00:49:42.162Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break this into subtasks that (1) analyze any existing pooling utilities or patterns, (2) design the pool API (central manager vs per-type pools, lifecycle methods, and configuration), (3) implement pooling for enemies, projectiles, pickups, and particles with pre-allocation, (4) refactor spawning/despawning call sites to use the pool instead of direct instantiation and queue_free, (5) add tooling or debug views to track pool usage and leaks, (6) integrate initialization and pre-warming into the main scene startup flow, and (7) create stress-test scenes to validate performance and correctness. For each subtask, capture expected interfaces, configuration options, and migration steps from existing code.",
        "updatedAt": "2025-12-13T00:49:42.162Z"
      },
      {
        "id": 7,
        "title": "Implement grid-based spatial partitioning for enemies",
        "description": "Add spatial hashing to optimize collision and proximity checks with many enemies.",
        "details": "Create a spatial grid system that maps grid cells (64×64 pixels) to arrays of enemy references, updating an enemy’s cell assignment only when it crosses a cell boundary.[1] Provide helper functions such as get_cell and get_nearby_enemies that return enemies in the same or adjacent cells, and refactor any existing naive O(n²) collision or proximity checks to use this system while retaining compatibility with current enemy and weapon code.[3]",
        "testStrategy": "Bench test with 100+ enemies active and verify that FPS remains at or near 60. Log the number of checks performed per frame before and after integration (if previous implementation exists) to validate performance improvements.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design grid data structures and cell size configuration",
            "description": "Define the spatial grid system with 64x64 pixel cells mapping to enemy arrays, including configuration for world bounds.",
            "dependencies": [],
            "details": "Create a GridManager class or resource with Dictionary<int, Array[Enemy]> for cells, cell_size=64, hash function for cell ID from position (floor(pos.x/64), floor(pos.y/64)). Export world bounds and cell size as variables for tuning. Ensure thread-safe access patterns.",
            "status": "done",
            "testStrategy": "Verify get_cell_id() returns consistent IDs for positions within same cell; test boundary cases where position exactly on cell edge. Goal: O(1) cell lookup.",
            "updatedAt": "2025-12-14T16:19:12.903Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement enemy registration and efficient movement updates",
            "description": "Add logic to register enemies in grid cells and update cell membership only when crossing boundaries.",
            "dependencies": [
              1
            ],
            "details": "Add _enter_tree() registration to compute initial cell and add to grid[cell_id]. Track previous_cell_id per enemy. In _physics_process(), check if new_cell != previous_cell; if changed, remove from old cell, add to new cell. Use enemy.global_position for calculations.\n<info added on 2025-12-15T05:42:17.235Z>\nSuccessfully implemented enemy grid registration and movement updates:\n\n- Added a `_current_cell_id` variable on enemies, initialized to -1 to indicate “not yet registered”.\n- On `on_spawn()`, enemies now call `GridManager.register_enemy(self)` and store the returned cell ID into `_current_cell_id`.\n- On `on_despawn()`, enemies call `GridManager.unregister_enemy(self, _current_cell_id)` to remove themselves from the grid before returning to the pool, and reset `_current_cell_id` back to -1.\n- `_physics_process(delta)` now recomputes the enemy’s cell from `global_position` each frame, but only updates the grid if the computed cell differs from `_current_cell_id`; when it changes, the enemy is removed from the old cell and added to the new one.\n- Verified behavior in `main.tscn` with both pooled and non-pooled enemies: non-pooled enemies still work via the existing `_ready()`/`on_spawn()` flow, but any enemy not spawned from the pool must ensure `GridManager.register_enemy()` is called (e.g., in `_ready()`).\n- Observed cell IDs as large hash integers (e.g., 196611, 262146) representing underlying (x, y) cell coordinates; these are now treated as opaque keys into the grid map.\n</info added on 2025-12-15T05:42:17.235Z>",
            "status": "done",
            "testStrategy": "Move enemy across 3+ cell boundaries; verify it appears only in correct current cell via debug logs. Performance goal: <5% enemies update cells per frame at 200px/s speed.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T05:41:54.808Z"
          },
          {
            "id": 3,
            "title": "Create helper query functions get_cell and get_nearby_enemies",
            "description": "Expose public functions to retrieve enemies in specific cells or adjacent 3x3/5x5 neighborhood.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement get_cell(cell_id: int) -> Array[Enemy]. Implement get_nearby_enemies(pos: Vector2, radius: float = 128) -> Array[Enemy] by computing center_cell + 8 neighbors (for radius~128px). Avoid duplicates with a temp Set. Cache neighbor offsets.",
            "status": "done",
            "testStrategy": "Query enemies at cell boundaries; verify returns enemies from correct adjacent cells without duplicates or misses. Goal: O(1) average query time regardless of total enemy count.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T18:47:54.609Z"
          },
          {
            "id": 4,
            "title": "Refactor collision/proximity checks to use spatial grid",
            "description": "Replace O(n²) loops in existing enemy-weapon collision and proximity code with grid-based queries.",
            "dependencies": [
              3
            ],
            "details": "Identify all existing collision checks (enemy vs weapon/projectile, enemy proximity for AI). Replace full enemy list iteration with get_nearby_enemies(weapon.global_position, weapon.range + enemy_radius). Preserve exact distance checks within candidates. Maintain identical behavior via same collision response code.",
            "status": "done",
            "testStrategy": "Run before/after comparison with identical enemy/weapon spawns; verify identical collision outcomes. Integration point: All Weapon/Projectile _physics_process() and Enemy AI update().",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T19:03:27.077Z"
          },
          {
            "id": 5,
            "title": "Add profiling and debug visualization for grid occupancy",
            "description": "Implement runtime visualization and stats logging for grid performance validation.",
            "dependencies": [
              4
            ],
            "details": "Add _draw() overlay showing grid cells as colored rectangles (green=empty, yellow=1-5 enemies, red=6+). Log per-frame stats: total_cells_used, avg_enemies_per_active_cell, grid_update_count, query_count. Toggle via debug_input action. Use Line2D or custom CanvasItem.\n<info added on 2025-12-15T22:33:38.419Z>\nImplemented GridManager debug stats (query_count, grid_update_count) and a move_enemy() helper that wraps unregister/register calls while updating these counters. Added a GridDebugOverlay scene that renders grid cells color-coded by occupancy (green = empty, yellow = 1–5 enemies, red = 6+), and displays live stats: total active cells used, average enemies per active cell, grid updates per frame, and query count (for future weapon collision queries). Bound the overlay toggle to the grid_debug input action mapped to F4 so it does not conflict with the existing F3 pool debug, and verified independent toggling. Fixed an enemy spawn registration issue in the pool_stress_test so enemies now register in the correct grid cell after being positioned instead of defaulting to (0,0). Verified behavior with 25+ enemies: ~22 cells used, ~1.14 average enemies per active cell, confirming correct spatial distribution and functioning visualization.\n</info added on 2025-12-15T22:33:38.419Z>",
            "status": "done",
            "testStrategy": "Spawn 0, 50, 200 enemies; verify visualization accurately shows occupancy patterns and stats scale correctly. Goal: Max 5% occupancy variance across cells in uniform distribution.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T22:33:15.682Z"
          },
          {
            "id": 6,
            "title": "Benchmark performance and tune under high enemy counts",
            "description": "Measure FPS and collision check efficiency with 100+ enemies; optimize cell size and query radius.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create benchmark scene spawning 100, 250, 500 enemies with random movement. Log collision_checks_per_frame before/after grid (target: 90%+ reduction). Test cell_sizes 32/64/96px. Tune based on uniform vs clustered enemy distributions. Target: 60FPS sustained at 300 enemies.\n<info added on 2025-12-15T23:17:52.796Z>\nCompleted grid benchmark testing with 100, 250, and 500 enemies across cell sizes 32px, 64px, and 96px.\n\nResults:\n- 64px cell size is optimal: 119 FPS at 500 enemies\n- 32px cell size: 106 FPS (too granular)\n- 96px cell size: 119 FPS (similar but less precise)\n\nKey findings:\n- System scales excellently: 119 FPS at 500 enemies (target was 60 FPS at 300)\n- Grid occupancy is well-distributed: ~224 active cells at 500 enemies\n- Cell size of 64px (2× sprite size) provides optimal query efficiency for weapon ranges (50-120px)\n\nRecommendation: Keep cell_size = 64 in GridManager. Target exceeded.\n\nBenchmark results saved to: game/test_reports/grid_benchmark_results.md\n</info added on 2025-12-15T23:17:52.796Z>",
            "status": "done",
            "testStrategy": "Automated benchmark reports delta_time, FPS, checks/frame at 3 enemy counts. Manual verification: Smooth gameplay at max load. Integration complete when existing gameplay code passes all physics/collision tests unchanged.",
            "parentId": "undefined",
            "updatedAt": "2025-12-15T23:17:55.345Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand into subtasks for (1) designing the grid data structures and cell size configuration, (2) implementing enemy registration and movement updates that adjust cell membership efficiently, (3) exposing helper queries such as get_cell and get_nearby_enemies, (4) refactoring collision and proximity logic to use the grid while staying compatible with current enemy/weapon systems, (5) adding profiling and debug visualization for grid occupancy, and (6) benchmarking and tuning under various enemy counts. For each subtask, define performance goals and integration points with existing gameplay code.",
        "updatedAt": "2025-12-15T23:17:55.345Z"
      },
      {
        "id": 8,
        "title": "Integrate auto-attack hooks for weapons",
        "description": "Prepare the player and game loop for automatic weapon firing compatible with the planned weapon system.",
        "details": "Add generic weapon slots or a weapon manager component to the player that tracks equipped weapons and their cooldowns, following any existing weapon or skill architecture in the project.[2] Ensure that weapons auto-attack based on their cooldowns without player input, exposing hooks for six planned weapons in later tasks and using the player’s Damage and Attack Speed multipliers to modify weapon behavior.[1]",
        "testStrategy": "Attach a simple test weapon (e.g., periodically spawning a debug projectile) and confirm that it fires automatically at the correct rate and responds to stat changes from the player component or progression systems.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design weapon management interface on player",
            "description": "Define slots, cooldown tracking, and stat modifier integration for extensibility with future weapons and passives.",
            "dependencies": [],
            "details": "Create a WeaponManager script on the player (CharacterBody2D from Task 4) with an array of 6 weapon slots, Dictionary for cooldown timers, and methods to apply player's Damage and Attack Speed multipliers. Use signals for attack hooks to allow passive modifications without tight coupling.",
            "status": "pending",
            "testStrategy": "Verify slots can be assigned null/weakref weapons, cooldowns decrement in _process, and multipliers scale base rates correctly via debug prints."
          },
          {
            "id": 2,
            "title": "Implement weapon manager component logic",
            "description": "Build update loop to manage cooldowns and trigger auto-attacks independently per slot.",
            "dependencies": [
              1
            ],
            "details": "In WeaponManager._process, iterate slots, decrement cooldowns delta-multiplied by attack speed, and call attack() on ready weapons targeting nearest enemy or forward direction. Expose equip(slot_id, weapon) and get_cooldown(slot_id) for future use.",
            "status": "pending",
            "testStrategy": "Log attack triggers and cooldown states; confirm no overlaps and correct firing rates independent of player input."
          },
          {
            "id": 3,
            "title": "Define minimal extensible weapon base class",
            "description": "Create IWeapon interface or base script for concrete weapons with auto-attack hooks.",
            "dependencies": [
              1
            ],
            "details": "Script with abstract attack(), get_base_cooldown(), get_base_damage() methods, plus virtual on_equip/passive_modifier hooks. Design for polymorphism so future weapons override behavior while sharing manager logic; integrate player stats via passed references.",
            "status": "pending",
            "testStrategy": "Instantiate base class, mock attack() to print stats, confirm it integrates with manager without errors."
          },
          {
            "id": 4,
            "title": "Integrate with pooling and spatial systems",
            "description": "Hook weapon attacks to spawn pooled projectiles or effects via spatial queries.",
            "dependencies": [
              2,
              3
            ],
            "details": "In weapon attack(), query nearest enemy via SpaceState2D (from Tasks 6/7), spawn pooled projectile from global pooler with direction/position from player, apply damage/scaling. Use signals for VFX/SFX; keep generic for non-projectile weapons later.",
            "status": "pending",
            "testStrategy": "Spawn debug projectiles, verify pooling reuse, spatial targeting picks correct enemy, and effects trigger."
          },
          {
            "id": 5,
            "title": "Build test weapon and diagnostic scene",
            "description": "Implement simple test weapon and scene to validate auto-firing and stat scaling.",
            "dependencies": [
              4
            ],
            "details": "Create TestWeapon extending base with 2s cooldown, 10 damage projectile spawn. Build scene with player, dummy enemies, stat UI; equip to slot 0. Ensure design uses slots/signals for easy swap to 6 future weapons and passive stat tests.",
            "status": "pending",
            "testStrategy": "Run scene: confirm auto-fire every ~2s (modulated by attack speed), damage scales with player stats, cooldown UI updates, no input required."
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Decompose into subtasks that (1) design or align the weapon management interface on the player (slots, cooldown tracking, stat modifiers), (2) implement a weapon manager or component that updates cooldowns and triggers attacks, (3) define a minimal weapon interface or base class that concrete weapons can implement, (4) integrate with pooling and spatial systems for spawning projectiles or effects, and (5) build a simple test weapon plus diagnostic scene to validate automatic firing and stat scaling. For each subtask, specify how to keep the design extensible for future weapons and passives."
      },
      {
        "id": 9,
        "title": "Implement basic progression loop scaffolding",
        "description": "Lay down the core systems for XP collection, leveling, and stat upgrades without full content.",
        "details": "Create a pickup type representing XP gems that the player collects within a Pickup Range of 50 pixels, ideally reusing the pooling system for pickups.[1] Implement a simple XP curve, level tracking, and a placeholder level-up UI that can present upgrade choices for weapons and passives later, aligning with any existing UI and progression frameworks already in the codebase.[2]",
        "testStrategy": "Spawn XP pickups in a test scene, collect them, and verify that player XP and level increase correctly, that a level-up screen appears at thresholds, and that choosing an option successfully applies a stat change or logs a placeholder effect.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Split into subtasks for (1) defining the XP pickup scene and pooling integration, (2) implementing the XP and level data model, including a configurable XP curve, (3) wiring XP collection into the player and progression components, (4) creating the placeholder level-up UI and flow (pause game, selection, apply effect), (5) integrating simple stat-upgrade or placeholder options that affect player stats or log debug output, and (6) building test scenarios to validate end-to-end leveling behavior. For each subtask, align data flow and UI patterns with existing progression and interface systems in the project."
      },
      {
        "id": 10,
        "title": "Performance validation for Week 3 target",
        "description": "Verify that the foundation meets the Week 3 performance and stability goals.",
        "details": "Create a dedicated performance test scene or mode that can spawn at least 100 active enemies using the pooling and spatial partitioning systems while the player moves and auto-attacks.[3] Measure FPS and frame time using Godot’s profiler to confirm stable 60 FPS under this load, and document any bottlenecks or further optimizations needed to reach the eventual 200+ enemy target.[1]",
        "testStrategy": "Run the performance scene on representative hardware, record FPS and profiler metrics, and ensure there are no major spikes in physics or script time. Adjust enemy update frequency or partitioning parameters if needed to maintain targets.",
        "priority": "high",
        "dependencies": [
          "4",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Organize into subtasks that (1) define the performance test scene or mode (enemy compositions, player setup, weapon behavior), (2) script automated or semi-automated load generation for enemies and attacks using existing pooling and spatial systems, (3) set up profiling procedures and metrics capture (FPS, frame time, script/physics cost), (4) document and triage any bottlenecks with proposed optimization tasks, and (5) create a repeatable checklist or script for rerunning the benchmark in future iterations. For each subtask, clarify target hardware assumptions and pass/fail thresholds tied to design goals."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-15T23:17:55.346Z",
      "taskCount": 10,
      "completedCount": 7,
      "tags": [
        "master"
      ],
      "created": "2025-12-16T19:21:13.334Z",
      "description": "Tasks for master context"
    }
  }
}